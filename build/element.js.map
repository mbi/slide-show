{
  "version": 3,
  "sources": ["../../fn/modules/cache.js", "../../fn/modules/curry.js", "../../fn/modules/maths/exponential-out.js", "../../fn/modules/noop.js", "../../fn/modules/apply.js", "../../fn/modules/id.js", "../../fn/modules/pipe.js", "../../fn/modules/denormalise.js", "../../dom/modules/transition.js", "../../dom/modules/animate.js", "../../dom/modules/rect.js", "../../dom/polyfills/element.scrollto.js", "../../fn/modules/equals.js", "../../fn/modules/nothing.js", "../../fn/modules/is-iterable.js", "../../fn/modules/stream/stopable.js", "../../fn/modules/stream/producer.js", "../../fn/modules/stream/buffer-producer.js", "../../fn/modules/stream/promise-producer.js", "../../fn/modules/stream/stream.js", "../../fn/modules/stream/broadcast.js", "../../fn/modules/stream/combine-producer.js", "../../fn/modules/stream/merge-producer.js", "../../fn/modules/stream/zip-producer.js", "../../fn/modules/stream.js", "../../fn/modules/overload.js", "../../dom/modules/assign.js", "../../dom/modules/create.js", "../../dom/modules/delegate.js", "../../fn/modules/exec.js", "../../fn/modules/capture.js", "../../dom/modules/log.js", "../../dom/modules/element.js", "../../dom/modules/element/create-boolean.js", "../../fn/modules/remove.js", "../../dom/modules/element/create-token-list.js", "../../dom/modules/events.js", "../../fn/modules/get.js", "../../fn/modules/to-type.js", "../../fn/modules/parse-value.js", "../../dom/modules/style.js", "../../dom/modules/parse-length.js", "../../dom/modules/gestures.js", "../../dom/modules/scrolls.js", "../modules/consts.js", "../../dom/modules/trigger.js", "../modules/active.js", "../modules/swipes.js", "../modules/autoplay.js", "../modules/loop.js", "../modules/navigation.js", "../modules/controls.js", "../modules/pagination.js", "../modules/fullscreen.js", "../../dom/modules/fullscreen.js", "../element.js"],
  "sourcesContent": ["/**\ncache(fn)\nReturns a function that caches the output values of `fn(input)`\nagainst input values in a map, such that for each input value\n`fn` is only ever called once.\n*/\n\nlet warned;\n\nexport default function cache(fn) {\n    var map = new Map();\n\n    return function cache(object) {\n        if (window.DEBUG && !warned && object === undefined) {\n            warned = true;\n            console.warn('cache() called with undefined. Not illegal, but worthy of a warning.');\n        }\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cache() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        if (map.has(object)) {\n            return map.get(object);\n        }\n\n        var value = fn(object);\n        map.set(object, value);\n        return value;\n    };\n}\n", "/**\ncurry(fn [, muteable, arity])\nReturns a function that wraps `fn` and makes it partially applicable.\n*/\n\nimport cache from './cache.js';\n\nconst A     = Array.prototype;\n\nfunction applyFn(fn, args) {\n    return typeof fn === 'function' ? fn.apply(null, args) : fn ;\n}\n\nfunction curry(fn, muteable, arity) {\n    arity = arity || fn.length;\n\n    var memo = arity === 1 ?\n        // Don't cache if `muteable` flag is true\n        muteable ? fn : cache(fn) :\n\n        // It's ok to always cache intermediate memos, though\n        cache(function(object) {\n            return curry(function() {\n                var args = [object];\n                args.push.apply(args, arguments);\n                return fn.apply(null, args);\n            }, muteable, arity - 1) ;\n        }) ;\n\n    return function partial(object) {\n        return arguments.length === 0 ?\n            partial :\n        arguments.length === 1 ?\n            memo(object) :\n        arguments.length >= arity ?\n            fn.apply(null, arguments) :\n        // This is bad, I think. We don't want [[fn],[fn]].map(get(0)) to be firing the fns\n        //arguments.length > arity ?\n        //    applyFn(fn.apply(null, A.splice.call(arguments, 0, arity)), arguments) :\n        applyFn(memo(object), A.slice.call(arguments, 1)) ;\n    };\n}\n\n//function curry(fn, muteable, arity) {\n//    arity = arity || fn.length;\n//    return function curried() {\n//        return arguments.length >= arity ?\n//            fn.apply(null, arguments) :\n//            curried.bind(null, ...arguments) ;\n//    };\n//}\n\nif (window.DEBUG) {\n    const _curry = curry;\n\n    // Feature test\n\tconst isFunctionLengthDefineable = (function() {\n\t\tvar fn = function() {};\n\n\t\ttry {\n\t\t\t// Can't do this on Safari - length non configurable :(\n\t\t\tObject.defineProperty(fn, 'length', { value: 2 });\n\t\t}\n\t\tcatch(e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn fn.length === 2;\n\t})();\n\n    const setFunctionProperties = function setFunctionProperties(text, parity, fn1, fn2) {\n        // Make the string representation of fn2 display parameters of fn1\n        fn2.toString = function() {\n            return /function\\s*[\\w\\d]*\\s*\\([,\\w\\d\\s]*\\)/.exec(fn1.toString()) + ' { [' + text + '] }';\n        };\n\n        // Where possible, define length so that curried functions show how\n        // many arguments they are yet expecting\n        if (isFunctionLengthDefineable) {\n            Object.defineProperty(fn2, 'length', { value: parity });\n        }\n\n        return fn2;\n    };\n\n    // Make curried functions log a pretty version of their partials\n    curry = function curry(fn, muteable, arity) {\n        arity  = arity || fn.length;\n        return setFunctionProperties('curried', arity, fn, _curry(fn, muteable, arity));\n    };\n}\n\n\nexport default curry;\n", "// Exponential functions\n//\n// e - exponent\n// x - range 0-1\n//\n// eg.\n// var easeInQuad   = exponential(2);\n// var easeOutCubic = exponentialOut(3);\n// var easeOutQuart = exponentialOut(4);\n\nimport curry from '../curry.js';\n\nexport function exponentialOut(e, x) {\n    return 1 - Math.pow(1 - x, e);\n}\n\nexport default curry(exponentialOut);\n", "/**\nnoop()\nReturns undefined.\n*/\n\nexport default function noop() {}\n", "export default function apply(value, fn) {\n    return fn(value);\n}\n", "/**\nid(value)\nReturns `value`.\n*/\n\nexport default function id(value) { return value; }\n", "/**\npipe(fn1, fn2, ...)\nReturns a function that calls `fn1`, `fn2`, etc., passing the result of\ncalling one function to the next and returning the the last result.\n*/\n\nimport apply from './apply.js';\nimport id from './id.js';\n\nconst A = Array.prototype;\n\nexport default function pipe() {\n    const fns = arguments;\n    return fns.length ?\n        (value) => A.reduce.call(fns, apply, value) :\n        id ;\n}\n", "\nexport default function linear(min, max, value) {\n    return value * (max - min) + min;\n}\n", "\n\n/**\ntransition(duration, fn)\n\nCalls `fn` on each animation frame until `duration` seconds has elapsed. `fn`\nis passed a single argument `progress`, a number that ramps from `0` to `1` over\nthe duration of the transition. Returns a function that cancels the transition.\n\n```\ntransition(3, function(progress) {\n    // Called every frame for 3 seconds\n});\n```\n*/\n\nconst performance           = window.performance;\nconst requestAnimationFrame = window.requestAnimationFrame;\nconst cancelAnimationFrame  = window.cancelAnimationFrame;\n\nexport default function transition(duration, fn, end) {\n\tvar t0 = performance.now();\n\n\tfunction frame(t1) {\n\t\t// Progress from 0-1\n\t\tvar progress = (t1 - t0) / (duration * 1000);\n\n\t\tif (progress < 1) {\n\t\t\tif (progress > 0) {\n\t\t\t\tfn(progress);\n\t\t\t}\n\t\t\tid = requestAnimationFrame(frame);\n\t\t}\n\t\telse {\n\t\t\tfn(1);\n\t\t\tend && end();\n\t\t}\n\t}\n\n\tvar id = requestAnimationFrame(frame);\n\n\treturn function cancel() {\n\t\tcancelAnimationFrame(id);\n\t};\n}\n", "\n\n/**\nanimate(duration, transform, name, object, value)\n\nAnimates property `name` of `object` to `value` over `duration` seconds, using\nthe `transform` function as an easing function, and updates the object on\nanimation frames.\n\n```\nduration  - number in seconds\ntransform - function that maps x (0-1) to y (0-1)\nname      - string name of property to animate\nobject    - object to animate\nvalue     - target value\nfn        - optional function to call on completion\n```\n*/\n\nimport pipe        from '../../fn/modules/pipe.js';\nimport denormalise from '../../fn/modules/denormalise.js';\nimport transition  from './transition.js';\n\nexport default function animate(duration, transform, name, object, stopValue, fn) {\n\t// denormaliseLinear is not curried! Wrap it.\n    const startValue = object[name];\n\treturn transition(\n\t\tduration,\n\t\tpipe(transform, (progress) => denormalise(startValue, stopValue, progress), (value) => (object[name] = value)),\n\t\tfn\n\t);\n}\n", "\n/**\nrect(node)\n\nReturns a `DOMRect` object describing the draw rectangle of `node`.\n(If `node` is `window` a preudo-DOMRect object is returned).\n**/\n\nfunction windowBox() {\n\treturn {\n\t\tx:      0,\n\t\ty:      0,\n\t\tleft:   0,\n\t\ttop:    0,\n\t\tright:  window.innerWidth,\n\t\tbottom: window.innerHeight,\n\t\twidth:  window.innerWidth,\n\t\theight: window.innerHeight\n\t};\n}\n\nexport default function rect(node) {\n\treturn node === window ?\n\t\twindowBox() :\n        // In Safari SVG shapes dont get a .getClientRects()[0] so fallback to\n        // .getBoundingClientRect()\n\t\tnode.getClientRects()[0] || node.getBoundingClientRect() ;\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { rect });\n}\n", "/**\nelement.scrollTo()\n\nMonkey patches `Element.scrollTo()` to support smooth scrolling options.\nhttps://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTo\n**/\n\nimport expOut   from '../../fn/modules/maths/exponential-out.js';\nimport noop     from '../../fn/modules/noop.js';\nimport animate  from '../modules/animate.js';\nimport rect     from '../modules/rect.js';\n\n// Duration and easing of scroll animation\nconst config = {\n    scrollDuration: 0.3,\n    scrollDurationPerHeight: 0.125,\n    scrollTransform: expOut(3)\n};\n\nlet cancel = noop;\n\nfunction scrollToPosition(scrollParent, options) {\n    if (options.behavior === 'smooth') {\n        // Switch off scroll snap\n        const scrollSnapType = scrollParent.style.getPropertyValue('scroll-snap-type');\n        const undoScrollSnap = () => (scrollParent.style.setProperty('scroll-snap-type', scrollSnapType));\n        scrollParent.style.setProperty('scroll-snap-type', 'none');\n\n        if (options.left !== undefined) {\n            const scrollBoxWidth = scrollParent === document.body ?\n                // We cannot guarantee that body width is 100%. Use the window\n                // innerHeight instead.\n                window.innerWidth :\n                rect(scrollParent).width ;\n\n            const scrollDuration = config.scrollDuration\n                + config.scrollDurationPerHeight\n                * Math.abs(options.left - scrollParent.scrollLeft)\n                / scrollBoxWidth ;\n\n            // duration, transform, name, object, value, endFn\n            cancel = animate(scrollDuration, config.scrollTransform, 'scrollLeft', scrollParent, options.left, undoScrollSnap);\n        }\n        else {\n            const scrollBoxHeight = scrollParent === document.body ?\n                // We cannot guarantee that body height is 100%. Use the window\n                // innerHeight instead.\n                window.innerHeight :\n                rect(scrollParent).height ;\n\n            const scrollDuration = config.scrollDuration\n                + config.scrollDurationPerHeight\n                * Math.abs(options.top - scrollParent.scrollTop)\n                / scrollBoxHeight ;\n\n            cancel = animate(scrollDuration, config.scrollTransform, 'scrollTop', scrollParent, options.top, undoScrollSnap);\n        }\n    }\n    else {\n        options.left !== undefined && (scrollParent.scrollLeft = options.left) ;\n        options.top  !== undefined && (scrollParent.scrollTop  = options.top) ;\n    }\n}\n\nif (!('scrollBehavior' in document.documentElement.style)) {\n    console.log('Polyfilling Element.scrollTo(options).');\n\n    // Get the method from HTMLElement - in some browsers it is here rather\n    // than on Element\n    const constructor = 'scrollTo' in Element.prototype ? Element : HTMLElement ;\n    const scrollTo    = constructor.scrollIntoView;\n\n    constructor.prototype.scrollTo = function(options) {\n        if (typeof options === 'object') {\n            scrollToPosition(this, options);\n        }\n        else {\n            scrollTo.apply(this, arguments);\n        }\n    };\n}\n", "\n/**\nequals(a, b)\nPerform a deep equality comparison of `a` and `b`. Returns `true` if\nthey are equal.\n*/\n\nimport curry from './curry.js';\n\nexport function equals(a, b) {\n    // Fast out if references are for the same object\n    if (a === b) { return true; }\n\n    // If either of the values is null, or not an object, we already know\n    // they're not equal so get out of here\n    if (a === null ||\n        b === null ||\n        typeof a !== 'object' ||\n        typeof b !== 'object') {\n        return false;\n    }\n\n    // Compare their enumerable keys\n    const akeys = Object.keys(a);\n    const bkeys = Object.keys(b);\n\n    let n = akeys.length;\n    while (n--) {\n        // Has the property been set to undefined on a?\n        if (a[akeys[n]] === undefined) {\n            // We don't want to test if it is an own property of b, as\n            // undefined represents an absence of value\n            if (b[akeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // console.log(equals(a[akeys[n]], b[akeys[n]]), akeys[n], a[akeys[n]], b[akeys[n]]);\n            if (!b.hasOwnProperty(akeys[n]) || !equals(a[akeys[n]], b[akeys[n]])) {\n                return false;\n            }\n        }\n\n        const i = bkeys.indexOf(akeys[n]);\n        if (i > -1) {\n            bkeys.splice(i, 1);\n        }\n    }\n\n    n = bkeys.length;\n    while (n--) {\n        // Has the property been set to undefined on b?\n        if (b[bkeys[n]] === undefined) {\n            if (a[bkeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // We already know a does not have own property bkeys[n], because\n            // we have already been through all the enumerable properties\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport default curry(equals, true);\n", "import noop from './noop.js';\n\nconst define = Object.defineProperties;\nconst freeze = Object.freeze;\n\nfunction self() {\n    return this;\n}\n\nexport default freeze(define([], {\n    // Make array and stream methods no-ops\n    shift:   { value: noop },\n    push:    { value: noop },\n    each:    { value: noop },\n    forEach: { value: noop },\n    start:   { value: noop },\n    stop:    { value: noop },\n    done:    { value: noop },\n    join:    { value: function() { return ''; } },\n    map:     { value: self },\n    filter:  { value: self },\n    reduce:  { value: function(fn, accumulator) { return accumulator; } }\n}));\n", "\n/**\nisIterable(value)\n**/\n\nexport default function isIterable(object) {\n    return object && object[Symbol.iterator];\n}\n", "\nconst assign = Object.assign;\n\nfunction stopOne(stopable) {\n    return stopable.stop ?\n        stopable.stop() :\n        stopable() ;\n}\n\nfunction stopAll(stopables) {\n    stopables.forEach(stopOne);\n    stopables.length = 0;\n}\n\n\n/**\nStopable()\n**/\n\nexport default function Stopable() {}\n\nassign(Stopable.prototype, {\n    stop: function stop() {\n        this.stopables && stopAll(this.stopables);\n        return this;\n    },\n\n    done: function done(fn) {\n        const stopables = this.stopables || (this.stopables = []);\n        stopables.push(fn);\n        return this;\n    }\n});\n", "\nimport Stopable from './stopable.js';\nconst assign = Object.assign;\n\n/*\nProducer\n*/\n\nexport function stop(stream) {\n    // Call done functions (in stream order - is this the best order, or would reverse order be better?)\n    Stopable.prototype.stop.apply(stream);\n\n    let n = -1;\n    let output;\n    while (output = stream[++n]) {\n        stream[n] = undefined;\n        stop(output);\n    }\n}\n\nexport default function Producer() {}\n\nassign(Producer.prototype, {\n    pipe: function(stream) {\n        this[0] = stream;\n    },\n\n    stop: function() {\n        stop(this[0]);\n    }\n});\n", "\nimport Producer from './producer.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\n\n/*\nBufferProducer\n*/\n\nexport default function BufferProducer(buffer) {\n    this.buffer = buffer;\n}\n\nassign(BufferProducer.prototype, Producer.prototype, {\n    // Opt in to having the Stream push to this producer\n    pushable: true,\n\n    push: function(value) {\n        const stream = this[0];\n\n        if (stream) {\n            stream[0].push(value);\n        }\n        else {\n            this.buffer.push(value);\n        }\n    },\n\n    pipe: function(stream) {\n        this[0] = stream;\n\n        // Empty buffer\n        while(this.buffer.length) {\n            stream[0].push(A.shift.apply(this.buffer));\n        }\n    }\n});\n", "\nimport nothing  from '../nothing.js';\nimport Producer from './producer.js';\n\nconst assign = Object.assign;\n\n\n/*\nPromiseProducer()\n*/\n\nexport default function PromiseProducer(promise) {\n    this.promise = promise;\n}\n\nassign(PromiseProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        const promise = this.promise;\n\n        this[0] = stream;\n\n        promise\n        .then((value) => this[0].push(value))\n        .finally((value) => this.stop());\n    },\n\n    stop: function() {\n        Producer.prototype.stop.apply(this, arguments);\n\n        // Make sure any remaining signals from the promise are not transmitted\n        // to output.\n        this[0] = nothing;\n    }\n});\n", "\nimport isIterable      from '../is-iterable.js';\nimport Stopable        from './stopable.js';\nimport { stop }        from './producer.js';\nimport BufferProducer  from './buffer-producer.js';\nimport PromiseProducer from './promise-producer.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\nconst create = Object.create;\n\n\n/* Stream */\n\nfunction push(stream, value) {\n    if (value !== undefined) {\n        stream[0].push(value);\n    }\n}\n\nfunction pushToProducer(value) {\n    this.input.push(value);\n}\n\nfunction unpipe(stream, output) {\n    // Support broadcast streams: streams with more than 1 output. Remove output\n    // from outputs then send stop signal to output and all its descendants.\n    if (stream[1]) {\n        let n = -1;\n        while (stream[++n] && stream[n] !== output);\n        while (stream[n++]) { stream[n - 1] = stream[n]; }\n        stop(output);\n    }\n\n    // Otherwise keep going back up the chain looking for a point to launch\n    // stop signal.\n    else {\n        stream.stop();\n    }\n}\n\nexport default function Stream(producer) {\n    this.input = producer;\n\n    if (this.input.pushable) {\n        console.log('Wiring up .push() to push to ' + this.input.constructor.name);\n        this.push = pushToProducer;\n    }\n}\n\nassign(Stream, {\n    /**\n    Stream.of(value1, value2, ...)\n    Creates a buffer stream from parameters.\n    **/\n    of: function() {\n        return new Stream(new BufferProducer(A.slice.apply(arguments)));\n    },\n\n    /**\n    Stream.from(source)\n    Creates a stream from a `source`, which may be an array (or array-like),\n    a promise, or a producer.\n    **/\n    from: function(source) {\n            // Source is a stream or producer\n        return source.pipe ? new Stream(source) :\n            // Source is a promise\n            source.then ? new Stream(new PromiseProducer(source)) :\n            // Source is an array-like\n            new Stream(new BufferProducer(source));\n    }\n});\n\nassign(Stream.prototype, Stopable.prototype, {\n    /**\n    .push(value)\n    Pushes `value` into the stream. If the stream has not been started or is\n    already stopped this will cause an error.\n    **/\n    push: function(value) {\n        if (window.DEBUG && !this[0]) {\n            throw new Error('Stream: attempt to .push() to a stopped stream (has a producer not been stopped correctly?)');\n        }\n\n        push(this, value);\n    },\n\n    /**\n    .pipe(stream)\n    Starts a stream and pushes its values into `stream`. Returns `stream`.\n    **/\n    pipe: function(output) {\n        if (this[0]) {\n            throw new Error('Stream: Attempt to .pipe() a unicast stream multiple times. Create a multicast stream with stream.broadcast().');\n        }\n\n        this[0] = output;\n        this.input.pipe(this);\n        return output;\n    },\n\n    /**\n    .map(fn)\n    Maps each value in the stream to `fn(value)`. Resulting values that are not\n    `undefined` are pushed downstream.\n    **/\n    map: function(fn) {\n        return new Map(this, fn);\n    },\n\n    /**\n    .filter(fn)\n    Filters out values from the stream where `fn(value)` is falsy.\n    **/\n    filter: function(fn) {\n        return new Filter(this, fn);\n    },\n\n    /**\n    .flatMap(fn)\n    **/\n    flatMap: function(fn) {\n        return new FlatMap(this, fn);\n    },\n\n    /**\n    .take(n)\n    Returns a stream of the first `n` values of the stream.\n    **/\n    take: function(n) {\n        return new Take(this, n);\n    },\n\n    /**\n    .each(fn)\n    Starts the stream and calls `fn(value)` for each value in it.\n    Returns the stream.\n    **/\n    each: function(fn) {\n        return new Each(this, fn);\n    },\n\n    /**\n    .reduce(fn, initial)\n    Consumes the stream. TODO: Not sure what to return old boy.\n    **/\n    reduce: function(fn, accumulator) {\n        return new Reduce(this, fn, accumulator);\n    },\n\n    /**\n    .scan(fn, initial)\n    Calls `fn(current, value)` for each `value` in the stream. Where `fn`\n    returns a value it is pushed downstream, and `current` assumes that value\n    on the next iteration. Where `fn` returns `undefined` nothing is pushed and\n    `current` remains unchanged.\n    **/\n    scan: function(fn, initial) {\n        return new Scan(this, fn, initial);\n    },\n\n    /**\n    .stop()\n    Stops the stream.\n    **/\n    stop: function() {\n        // We send to unpipe() to support broadcast streams, a unicast stream\n        // at input only requires this.input.stop()\n        unpipe(this.input, this);\n        return this;\n    }\n\n    /**\n    .done(fn)\n    Cues `fn` to be called when the stream is stopped.\n    **/\n});\n\n\n/* Map */\n\nfunction Map(input, fn) {\n    this.input = input;\n    this.fn    = fn;\n}\n\nMap.prototype = assign(create(Stream.prototype), {\n    push: function map(value) {\n        const fn = this.fn;\n        push(this, fn(value));\n    }\n});\n\n\n/* Filter */\n\nfunction Filter(input, fn) {\n    this.input = input;\n    this.fn    = fn;\n}\n\nFilter.prototype = assign(create(Stream.prototype), {\n    push: function filter(value) {\n        const fn = this.fn;\n        const is = fn(value);\n        is && push(this, value);\n    }\n});\n\n\n/* FlatMap */\n\nfunction FlatMap(input, fn) {\n    this.input = input;\n    this.fn    = fn;\n}\n\nFlatMap.prototype = assign(create(Stream.prototype), {\n    push: function flatMap(value) {\n        const fn     = this.fn;\n        const values = fn(value);\n\n        if (values !== undefined) {\n            if (isIterable(values)) {\n                for (const value of values) {\n                    push(this, value);\n                }\n            }\n            else {\n                // Todo: support flattening of streams. Should streams by made\n                // iterable? CAN streams be made iterable? They'd have to be async?\n                throw new Error('Stream: Cannot .flatMap() non-iterable values');\n            }\n        }\n    }\n});\n\n\n/* Take */\n\nfunction Take(input, n) {\n    if (window.DEBUG && (typeof n !== 'number' || n < 1)) {\n        throw new Error('Stream: .take() only accepts non-zero positive integers (' + n + ')');\n    }\n\n    this.input = input;\n    this.count = n;\n}\n\nTake.prototype = assign(create(Stream.prototype), {\n    push: function take(value) {\n        this[0].push(value);\n        if (!(--this.count)) {\n            this.stop();\n        }\n    }\n});\n\n\n/*\nReduce\n*/\n\nfunction Reduce(input, fn, accumulator) {\n    this.input = input;\n    this.fn    = fn;\n    this.value = accumulator;\n\n    // Start pulling values\n    input.pipe(this);\n\n    return accumulator;\n}\n\nReduce.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value);\n    }\n});\n\n\n/* Scan */\n\nfunction Scan(input, fn, accumulator) {\n    this.input = input;\n    this.fn    = fn;\n    this.value = accumulator;\n}\n\nScan.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        const fn = this.fn;\n        this.value = fn(this.value, value);\n        this[0].push(this.value);\n    }\n});\n\n\n/* Each */\n\nfunction Each(input, fn) {\n    this.input = input;\n    this.push  = fn;\n\n    // Start pulling values\n    input.pipe(this);\n}\n\nEach.prototype = assign(create(Stream.prototype), {\n    each:   null,\n    reduce: null,\n    pipe:   null\n});\n", "\nimport nothing from '../nothing.js';\nimport Stream  from './stream.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\n\n\n/*\nBroadcast(producer, options)\nA Broadcast stream may be piped to multiple outputs. The options object has\nthe optional properties:\n\n```js\n{\n    // Remember and send the latest value to new pipes\n    memory: true,\n\n    // Start the stream immediately and keep it alive after all pipes are stopped\n    hot:    true\n}\n```\n*/\n\nexport default function Broadcast(producer, options) {\n    Stream.apply(this, arguments);\n\n    // Mark this stream as a memory stream\n    this.memory = !!(options && options.memory);\n\n    // Open the stream immediately and keep it live even without outputs by\n    // sending output 0 to nothing. It can now only be stopped by explicitly\n    // calling .stop() on it, and not by stopping child streams.\n    if (options && options.hot) {\n        this.pipe(nothing);\n    }\n}\n\nBroadcast.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        if (value !== undefined) {\n            // If this is a memory stream keep value\n            if (this.memory) {\n                this.value = value;\n            }\n\n            let n = -1;\n            while (this[++n]) {\n                this[n].push(value);\n            }\n        }\n    },\n\n    pipe: function(output) {\n        let n = -1;\n        while (this[++n]);\n        this[n] = output;\n\n        // If this is a memory stream, ie has value already\n        if (this.value !== undefined) {\n            output.push(this.value);\n        }\n\n        if (n === 0) {\n            this.input.pipe(this);\n        }\n\n        return output;\n    }\n});\n", "\nimport Producer from './producer.js';\n\nconst assign = Object.assign;\nconst keys   = Object.keys;\n\n/*\nCombineProducer\n*/\n\nfunction push(producer, name, value) {\n    const values = producer.values;\n    const names  = producer.names;\n    const stream = producer[0];\n\n    values[name] = value;\n\n    if (producer.active || (producer.active = keys(values).length === names.length)) {\n        stream.push(assign({}, values));\n    }\n}\n\nexport default function CombineProducer(sources) {\n    this.sources = sources;\n}\n\nassign(CombineProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        const sources = this.sources;\n\n        this.values = {};\n        this.names  = keys(sources);\n        this.active = false;\n        this[0]     = stream;\n\n        for (const name in sources) {\n            const source = sources[name];\n\n            if (source.each) {\n                stream.done(source.each((value) => push(this, name, value)));\n            }\n            else if (source.then) {\n                source.then((value) => push(this, name, value));\n                //.finally((value) => stop(this[0]));\n            }\n            else {\n                console.log('Todo: combine() raw values ?');\n            }\n        }\n    }\n});\n", "\nimport Producer from './producer.js';\n\nconst assign = Object.assign;\n\n/*\nMergeProducer\n*/\n\nexport default function MergeProducer(inputs) {\n    this.inputs = inputs;\n}\n\nassign(MergeProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        const inputs = this.inputs;\n\n        this[0] = stream;\n\n        let i = -1;\n        let input;\n        while (input = inputs[++i]) {\n            // Input is a stream\n            if (input.each) {\n                input.pipe(stream);\n            }\n\n            // Input is a promise\n            else if (input.then) {\n                input\n                .then((value) => stream.push(value));\n                //.finally((value) => stop(this[0]));\n            }\n\n            // Input is an array-like\n            else {\n                let n = -1;\n                while (++n < input.length) {\n                    stream.push(input[n]);\n                }\n            }\n        }\n    }\n});\n", "\nimport Producer from './producer.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\n\n/*\nZipProducer\n*/\n\nfunction hasLength(buffer) {\n    return buffer.length > 0;\n}\n\nfunction toObject(object, buffer, i) {\n    object[i] = buffer.shift();\n    return object;\n}\n\nfunction makeArray(object) {\n    return [];\n}\n\nfunction fillBuffer(controller, buffers, buffer, value) {\n    buffer.push(value);\n    if (buffers.every(hasLength)) {\n        controller.push(buffers.reduce(toObject, {}));\n    }\n}\n\n\nexport default function ZipProducer(inputs) {\n    this.inputs  = inputs;\n    this.buffers = A.map.call(inputs, makeArray);\n}\n\nassign(ZipProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        const inputs  = this.inputs;\n        const buffers = this.buffers;\n\n        this[0] = stream;\n\n        A.forEach.call(inputs, (input, i) => {\n            const buffer = buffers[i];\n\n            // Support streams\n            if (input.each) {\n                // Stop stream when controller stops - we wrap stream.each like\n                // this because stream may be a broadcaster and we don't want to\n                // stop that.\n                stream.done(\n                    input.each((value) => fillBuffer(stream, buffers, buffer, value))\n                );\n            }\n            // Support promises\n            else if (input.then) {\n                input.then((value) => fillBuffer(stream, buffers, buffer, value));\n            }\n            // Support array-likes\n            else {\n                A.forEach.call(input, (value) => fillBuffer(stream, buffers, buffer, value));\n            }\n        });\n    }\n});\n", "\nimport nothing         from './nothing.js';\n\nimport Stream          from './stream/stream.js';\nimport Broadcast       from './stream/broadcast.js';\nimport BufferProducer  from './stream/buffer-producer.js';\nimport CombineProducer from './stream/combine-producer.js';\nimport MergeProducer   from './stream/merge-producer.js';\nimport ZipProducer     from './stream/zip-producer.js';\n\nconst assign = Object.assign;\n\nexport default assign(Stream, {\n    /**\n    Stream.broadcast(options)\n    Returns a pushable broadcast stream. Methods called on this stream each\n    create a new stream.\n    **/\n    broadcast: function broadcast(options) {\n        return new Broadcast(new BufferProducer(nothing), options);\n    },\n\n    /**\n    Stream.combine(streams)\n    Creates a stream by combining the latest values of all input streams into\n    an objects containing those values. A new object is emitted when a new value\n    is pushed to any input stream.\n    **/\n    combine: function combine(streams) {\n        return new Stream(new CombineProducer(streams));\n    },\n\n    /**\n    Stream.merge(stream1, stream2, ...)\n    Creates a stream by merging values from any number of input streams into a\n    single output stream.\n    **/\n    merge: function() {\n        return new Stream(new MergeProducer(arguments));\n    },\n\n    /**\n    Stream.zip(stream1, stream2, ...)\n    Creates a stream by merging values from any number of input streams into a\n    single output stream.\n    **/\n    zip: function() {\n        return new Stream(new ZipProducer(arguments));\n    }\n});\n\nassign(Stream.prototype, {\n    /**\n    .broadcast(options)\n    Returns a broadcast stream. Methods called on this stream each create new\n    child streams. The first time a consumer is attached to one of these streams\n    the broadcast stream is piped, and the last consumer to be stopped stops the\n    broadcast stream.\n\n    A broadcast stream may have memory, where newly created consumers\n    immediately receive the latest value of the broadcaster when attached\n    (assuming that value is not `undefined`):\n\n    ```js\n    const broadcaster = stream.broadcast({ memory: true });\n    ```\n    **/\n    broadcast: function(options) {\n        return new Broadcast(this, options);\n    }\n});\n\n\n// Debug\n\nif (window.DEBUG) {\n    window.Stream = Stream;\n}\n\n", "/**\noverload(fn, map)\n\nReturns a function that calls a function at the property of `object` that\nmatches the result of calling `fn` with all arguments.</p>\n\n```\nvar fn = overload(toType, {\n    string: function a(name, n) {...},\n    number: function b(n, m) {...}\n});\n\nfn('pie', 4); // Returns a('pie', 4)\nfn(1, 2);     // Returns b(1, 2)\n```\n*/\n\n\nexport default function overload(fn, map) {\n    return function overload() {\n        const key     = fn.apply(this, arguments);\n        const handler = (map[key] || map.default);\n\n        if (!handler) {\n            throw new Error('overload() no handler for \"' + key + '\"');\n        }\n\n        return handler.apply(this, arguments);\n    };\n}\n", "/**\nassign(node, properties)\n\nAssigns each property of `properties` to `node`, as a property where that\nproperty exists in `node`, otherwise as an attribute.\n\nIf `properties` has a property `'children'` it must be an array of nodes;\nthey are appended to 'node'.\n\nThe property `'html'` is aliased to `'innerHTML'`. The property `'text'` \nis aliased to `'textContent'`. The property `'tag'` is treated as an alias \nof `'tagName'` (which is ignored, as `node.tagName` is read-only). The \nproperty `'is'` is also ignored.\n*/\n\nimport curry from '../../fn/modules/curry.js';\nimport id from '../../fn/modules/id.js';\nimport noop from '../../fn/modules/noop.js';\nimport overload from '../../fn/modules/overload.js';\n\nconst assignProperty = overload(id, {\n\t// Ignore read-only properties or attributes\n\tis: noop,\n\ttag: noop,\n\n\thtml: function(name, node, content) {\n\t\tnode.innerHTML = content;\n\t},\n\n\ttext: function(name, node, content) {\n\t\tnode.textContent = content;\n\t},\n\n\tchildren: function(name, node, content) {\n\t\t// Empty the node and append children\n\t\tnode.innerHTML = '';\n\t\tcontent.forEach((child) => { node.appendChild(child) });\n\t},\n\n\t// SVG points property must be set as string attribute - SVG elements\n\t// have a read-only API exposed at .points\n\tpoints: setAttribute,\n    cx:     setAttribute,\n    cy:     setAttribute,\n    r:      setAttribute,\n    preserveAspectRatio: setAttribute,\n    viewBox: setAttribute,\n\n\tdefault: function(name, node, content) {\n\t\tif (name in node) {\n\t\t\tnode[name] = content;\n\t\t}\n\t\telse {\n\t\t\tnode.setAttribute(name, content);\n\t\t}\n\t}\n});\n\nfunction setAttribute(name, node, content) {\n\tnode.setAttribute(name, content);\n}\n\nexport function assign(node, attributes) {\n\tvar names = Object.keys(attributes);\n\tvar n = names.length;\n\n\twhile (n--) {\n\t\tassignProperty(names[n], node, attributes[names[n]]);\n\t}\n\n\treturn node;\n}\n\nexport default curry(assign, true);\n", "\nimport id       from '../../fn/modules/id.js';\nimport overload from '../../fn/modules/overload.js';\nimport assign   from './assign.js';\n\nconst svgNamespace = 'http://www.w3.org/2000/svg';\n\nconst div           = document.createElement('div');\nconst typeofTag     = (tag, content)  => (tag && typeof tag);\nconst typeofContent = (type, content) => (content && typeof content);\n\n// Constructors\n\nfunction createContextFragment(context, html) {\n    const range = document.createRange();\n    range.selectNode(context);\n    return range.createContextualFragment(html);\n}\n\nfunction createSVG(tag, html) {\n    var node = document.createElementNS(svgNamespace, tag);\n\n    if (html) {\n        node.innerHTML = html;\n    }\n\n    return node;\n}\n\n/**\ncreate(tag, content)\n\nConstructs and returns a new DOM node.\n\n- If `tag` is `\"text\"` a text node is created.\n- If `tag` is `\"fragment\"` a fragment is created.\n- If `tag` is `\"comment\"` a comment is created.\n- If `tag` is any other string the element `<tag></tag>` is created.\n\nWhere a comment or text node is created `content` must be a string, as is set as\ntextContent. For fragments and other nodes:\n\n- If `content` is a string it is set as innerHTML.\n- If `content` is array-like its items are appended to node. Note that where\n`content` is a NodeList, this removes nodes from whatever the NodeList belongs\nto.\n- If `content` is an object its properties are assigned as node properties or\nattributes.\n\nWhere node is a fragment there is an optional third parameter `context`, which\nmust be an element. The fragment parser is run in the context of the element:\n\n```\ncreate('fragment', '<li>', document.querySelector('ul'));\n```\n**/\n\nconst create = overload(id, {\n    comment: function(tag, text) {\n        return document.createComment(text || '');\n    },\n\n    fragment: overload(typeofContent, {\n        string: function(tag, html, context) {\n            if (context) {\n                return createContextFragment(context, html);\n            }\n\n            const fragment = document.createDocumentFragment();\n            div.innerHTML = html;\n            const nodes = div.childNodes;\n            while (nodes[0]) { fragment.appendChild(nodes[0]); }\n            return fragment;\n        },\n\n        object: function(tag, object, context) {\n            // If there is context, create a context-aware fragment\n            const fragment = context ?\n                createContextFragment(context) :\n                document.createDocumentFragment() ;\n\n            // Is object array-like?\n            if (typeof object.length === 'number') {\n                // Be careful here in case object is a live NodeList, which will\n                // mutate as you iterate over it. Applying object to .append()\n                // appears to not have this problem, and will work on arrays.\n                fragment.append.apply(fragment, object);\n            }\n            else {\n                assign(fragment, object);\n            }\n\n            return fragment;\n        },\n\n        default: () => document.createDocumentFragment()\n    }),\n\n    text: function (tag, text) {\n        return document.createTextNode(text || '');\n    },\n\n    circle:   createSVG,\n    ellipse:  createSVG,\n    g:        createSVG,\n    glyph:    createSVG,\n    image:    createSVG,\n    line:     createSVG,\n    rect:     createSVG,\n    use:      createSVG,\n    path:     createSVG,\n    pattern:  createSVG,\n    polygon:  createSVG,\n    polyline: createSVG,\n    svg:      createSVG,\n\n    default: overload(typeofContent, {\n        string: function(tag, html) {\n            const node = document.createElement(tag);\n            node.innerHTML = html;\n            return node;\n        },\n\n        object: function(tag, object) {\n            const node = document.createElement(tag);\n\n            // Is it array-like?\n            if (typeof object.length === 'number') {\n                // Be careful here in case object is a live NodeList, which will\n                // mutate as you iterate over it. Applying object to .append()\n                // appears to not have this problem, and will work on arrays.\n                node.append.apply(node, object);\n            }\n            else {\n                assign(node, object);\n            }\n\n            return node;\n        },\n\n        default: (tag) => {\n            if (typeof tag !== 'string') {\n                // We used to support object as first argument. Deprecated.\n                // Todo: remove this message when we dont see any more errors\n                throw new Error('create(tag, content) accepts only a string as tag \"' + (typeof tag) + '\"')\n            }\n\n            return document.createElement(tag);\n        }\n    }),\n});\n\nexport default create;\n\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { create });\n}\n", "\n/** \ndelegate(map)\n\nTakes an object map of functions keyed to selectors, and returns a function that\nhandles event objects, delegating them to the first function whose selector \nmatches the event target. Functions are passed the target node and the event \nobject, plus any other arguments passed to the handler.\n\n```\ndelegate({\n\t'button': (button, event) => {}\n})\n```\n**/\n\nexport default function delegate(object) {\n\tif (typeof object !== 'object' || arguments.length > 1) {\n\t\tthrow new Error('delegate() now takes an object of selector:fn pairs.');\n\t}\n\n\t// Create an event handler that looks up the ancestor tree\n\t// to find selector.\n\tconst selectors = Object.keys(object);\n\n\treturn function handle(e) {\n\t\tconst target = e.target;\n\t\tlet n = -1;\n\n\t\twhile (selectors[++n]) {\n\t\t\tconst node = target.closest(selectors[n]);\n\t\t\tif (node) {\n\t\t\t\treturn object[selectors[n]](node, ...arguments);\n\t\t\t}\n\t\t}\n\t};\n}\n", "/**\nexec(regex, fn, string)\n\nCalls `fn` with the result of `regex.exec(string)` if that result is not null,\nand returns the resulting value.\n*/\n\nimport curry from './curry.js';\n\nexport function exec(regex, fn, string) {\n    let data;\n\n    // If string looks like a regex result, get rest of string\n    // from latest index\n    if (typeof string !== 'string' && string.input !== undefined && string.index !== undefined) {\n        data = string;\n        string = data.input.slice(\n            string.index\n            + string[0].length\n            + (string.consumed || 0)\n        );\n    }\n\n    // Look for tokens\n    const tokens = regex.exec(string);\n    if (!tokens) { return; }\n\n    const output = fn(tokens);\n\n    // If we have a parent tokens object update its consumed count\n    if (data) {\n        data.consumed = (data.consumed || 0)\n            + tokens.index\n            + tokens[0].length\n            + (tokens.consumed || 0) ;\n    }\n\n    return output;\n}\n\nexport default curry(exec, true);\n", "\nimport curry from './curry.js';\nimport { exec } from './exec.js';\n\nfunction error(regex, reducers, string) {\n    if (string.input !== undefined && string.index !== undefined) {\n        string = string.input;\n    }\n\n    throw new Error('Cannot parse string \"' + string + '\"');\n}\n\nfunction reduce(reducers, acc, tokens) {\n    let n = -1;\n\n    while (++n < tokens.length) {\n        acc = (tokens[n] !== undefined && reducers[n]) ? reducers[n](acc, tokens) : acc ;\n    }\n\n    // Call the optional done fn\n    return reducers.done ? reducers.done(acc, tokens) :\n        // Support the old .close() name\n        reducers.close ? reducers.close(acc, tokens) :\n        // Return the result\n        acc ;\n}\n\n/**\ncapture(regex, reducers, accumulator, string)\nParse `string` with `regex`, calling functions in `reducers` to modify\nand return `accumulator`.\n\nReducers is an object of functions keyed by the index of their capturing\ngroup in the regexp result (`0` corresponding to the entire regex match,\nthe first capturing group being at index `1`). Reducer functions are\ncalled in capture order for all capturing groups that captured something.\nReducers may also define the function 'done', which is called at the end\nof every capture. All reducer functions are passed the paremeters\n`(accumulator, tokens)`, where `tokens` is the regexp result, and are expected\nto return a value that is passed as an accumulator to the next reducer function.\n\nReducers may also define a function `'catch'`, which is called when a match\nhas not been made (where `'catch'` is not defined an error is thrown).\n\n```js\nconst parseValue = capture(/^\\s*(-?\\d*\\.?\\d+)(\\w+)?\\s*$/, {\n    // Create a new accumulator object each call\n    0: () => ({}),\n\n    1: (acc, tokens) => {\n        acc.number = parseFloat(tokens[1]);\n        return acc;\n    },\n\n    2: (acc, tokens) => {\n        acc.unit = tokens[2];\n        return acc;\n    }\n}, null);\n\nconst value = parseValue('36rem');    // { number: 36, unit: 'rem' }\n```\n*/\n\nexport function capture(regex, reducers, acc, string) {\n    const output = exec(regex, (tokens) => reduce(reducers, acc, tokens), string);\n\n    // If tokens is undefined exec has failed to apply regex to string\n    return output === undefined ?\n        // If there is a catch function, call it, otherwise error out\n        reducers.catch ?\n            reducers.catch(acc, string) :\n            error(regex, reducers, string) :\n\n        // Return the accumulator\n        output ;\n}\n\nexport default curry(capture, true);\n", "\nimport noop from '../../fn/modules/noop.js';\n\nexport default window.DEBUG ?\n    function log(name, ...args) {\n        if (window.console && window.console.log) {\n            window.console.log('%cdom %c' + name + '%c', 'color: #888888; font-weight: 400;', 'color: #3a8ab0; font-weight: 600;', 'color: inherit; font-weight: 400;', ...args);\n         }\n    } :\n    noop ;\n", "\n/**\nelement(name, options)\n\nRegisters a custom element and returns its constructor.\n\n- name: `'element-name'` or `'tag is=\"element-name\"'`\n- options: {\n    mode:       'open' or 'closed', defaults to 'closed'\n    focusable:  true or false, defaults to true\n    properties: An object of attribute and property handlers\n    \n    // Lifecycle handlers\n    stylesheet: optional string path to stylesheet for shadow DOM\n    construct:  called during element construction\n    connect:    called when element added to DOM\n    load:       called when stylesheet loaded\n    disconnect: called when element removed from DOM\n    enable:     called when form element enabled\n    disable:    called when form element disabled\n    reset:      called when form element reset\n    restore:    called when form element restored\n}\n\nThe name form `'tag is=\"element-name\"'` creates customised built-in elements in \nbrowsers that support the feature. Safari is a known culprit. Mileage will vary.\n\nThe effects of the `mode` option are subtle. In 'closed' mode, the element is\nnot given a publicly accessible `shadowRoot` property, and events that traverse\nthe shadow boundary are retargeted (as they are in 'open' mode) but also have\ntheir `path` list truncated.\n\nWhere the `properties` object contains a definition for a `value` property, work\nis done to give the element form field behaviour. The constructor is assigned\nthe property `formAssociated` which signals to the browser that it constructs\nform fields. Where they are not defined in `properties` the prototype is\nassigned default handlers for the standard properties `type`, `name`, `form`,\n`labels`, `validity`, `validationMessage`, `willValidate`, `checkValidity`\nand `reportValidity`. Form behaviour is also mildly polyfilled in browsers\nwithout support by inserting a hidden input inside the element but outside the\nshadow DOM. Mileage will vary. Managing focus can be problematic without browser \nsupport.\n\nAt the start of initialisation the `construct` handler is called. Use it to\nset up a shadow root and define event handlers. Children and attributes must\nnot be inspected or assigned at this point – doing so will throw in some cases,\neg. construction via `document.createElement()`.\n\nFollowing that, attribute handlers are called for attributes declared in the\nHTML. The parser normally calls these in source order, but this can be problematic\nif you require setup to run in a specific order so here they are run in the order\ndeclared in the `options.properties`.\n\nThen the `connect` handler is called when the element is placed in the DOM\nor if it is already in the DOM and is being upgraded.\n\nFinally the `load` handler is called after the first connect, and after any\nstylesheet links in the shadow DOM have loaded. If there are no links, it is\ncalled immediately after `connect`.\n\nAll lifecycle handlers are called with the parameter `(shadow)`.\n*/\n\nimport create  from './create.js';\nimport capture from '../../fn/modules/capture.js';\nimport log     from './log.js';\n\nconst $internals = Symbol('internals');\nconst $shadow    = Symbol('shadow');\n\nconst define = Object.defineProperties;\n\nconst constructors = {\n    // We need list only those whose constructor names do not match their tag\n    'a':        HTMLAnchorElement,\n    'dl':       HTMLDListElement,\n    'p':        HTMLParagraphElement,\n    'br':       HTMLBRElement,\n    'fieldset': HTMLFieldSetElement,\n    'hr':       HTMLHRElement,\n    'img':      HTMLImageElement,\n    'li':       HTMLLIElement,\n    'ol':       HTMLOListElement,\n    'optgroup': HTMLOptGroupElement,\n    'q':        HTMLQuoteElement,\n    'textarea': HTMLTextAreaElement,\n    'td':       HTMLTableCellElement,\n    'th':       HTMLTableCellElement,\n    'tr':       HTMLTableRowElement,\n    'tbody':    HTMLTableSectionElement,\n    'thead':    HTMLTableSectionElement,\n    'tfoot':    HTMLTableSectionElement,\n    'ul':       HTMLUListElement\n};\n\nconst formProperties = {\n    // These properties echo those provided by native form controls.\n    // They are not strictly required, but provided for consistency.\n    //type: { value: 'text' },\n\n    name: {\n        set: function(name) { return this.setAttribute('name', name); },\n        get: function() { return this.getAttribute('name') || ''; }\n    },\n\n    form:              { get: function() { return this[$internals].form; }},\n    labels:            { get: function() { return this[$internals].labels; }},\n    validity:          { get: function() { return this[$internals].validity; }},\n    validationMessage: { get: function() { return this[$internals].validationMessage; }},\n    willValidate:      { get: function() { return this[$internals].willValidate; }},\n    checkValidity:     { value: function() { return this[$internals].checkValidity(); }},\n    reportValidity:    { value: function() { return this[$internals].reportValidity(); }}\n};\n\nconst nothing   = {};\nconst onceEvent = { once: true };\nconst shadowParameterIndex = 0;\n\nlet supportsCustomisedBuiltIn = false;\n\nfunction getElementConstructor(tag) {\n        // Return a constructor from the known list of tag names – not all tags\n        // have constructor names that match their tags\n    return constructors[tag]\n        // Or assemble the tag name in the form \"HTMLTagElement\" and return\n        // that property of the window object\n        || window['HTML' + tag[0].toUpperCase() + tag.slice(1) + 'Element']\n        || (() => {\n            throw new Error('Constructor not found for tag \"' + tag + '\"');\n        })();\n}\n\n// Capture name and tag from <element-name> or <tag is=\"element-name\">, syntax\n// brackets and quotes optional\nconst captureNameTag = capture(/^\\s*<?([a-z][\\w]*-[\\w]+)>?\\s*$|^\\s*<?([a-z][\\w]*)\\s+is=[\"']?([a-z][\\w]*-[\\w]+)[\"']?>?\\s*$/, {\n    1: (data, captures) => ({\n        name: captures[1]\n    }),\n    \n    2: (data, captures) => ({\n        name: captures[3],\n        tag:  captures[2]\n    }),\n\n    catch: function(data, name) {\n        throw new SyntaxError('dom element() – name must be of the form \\'element-name\\' or \\'tag is=\"element-name\"\\' (' + name + ')')\n    }\n}, null);\n\nfunction transferProperty(elem, key) {\n    if (elem.hasOwnProperty(key)) {\n        const value = elem[key];\n        delete elem[key];\n        elem[key] = value;\n    }\n\n    return elem;\n}\n\nfunction createShadow(/*template, */elem, options) {\n    elem._initialLoad = true;\n\n    // Create a shadow root if there is DOM content. Shadows may be 'open' or\n    // 'closed'. Closed shadows are not exposed via element.shadowRoot, and\n    // events propagating from inside of them report the element as target.\n    const shadow = elem.attachShadow({\n        mode:           options.mode || 'closed',\n        delegatesFocus: options.focusable || false\n    });\n\n    if (options.stylesheet) {\n        const link = create('link', { rel: 'stylesheet', href: options.stylesheet });\n        shadow.append(link);\n    }\n\n    elem[$shadow] = shadow;\n\n    return shadow;\n}\n\nfunction attachInternals(elem) {\n    var internals;\n\n    // Use native attachInternals where it exists\n    if (elem.attachInternals) {\n        internals = elem.attachInternals();\n        if (internals.setFormValue) {\n            return internals;\n        }\n    }\n    else {\n        internals = {\n            shadowRoot: elem.shadowRoot\n        };\n    }\n\n    // Otherwise polyfill it with a pseudo internals object, actually a hidden\n    // input that we put inside element (but outside the shadow DOM). We may\n    // not yet put this in the DOM however – it violates the spec to give a\n    // custom element children before it's contents are parsed. Instead we\n    // wait until connectCallback.\n    internals.input = create('input', { type: 'hidden', name: elem.name });\n    elem.appendChild(internals.input);\n\n    // Polyfill internals object setFormValue\n    internals.setFormValue = function(value) {\n        this.input.value = value;\n    };\n\n    return internals;\n}\n\nfunction primeAttributes(elem) {\n    elem._initialAttributes = {};\n    elem._n = 0;\n}\n\nfunction advanceAttributes(elem, attributes, handlers) {\n    const values = elem._initialAttributes;\n\n    while(elem._n < attributes.length && values[attributes[elem._n]] !== undefined) {\n        //console.log('ADVANCE ATTR', attributes[elem._n]);\n        handlers[attributes[elem._n]].call(elem, values[attributes[elem._n]]);\n        ++elem._n;\n    }\n}\n\nfunction flushAttributes(elem, attributes, handlers) {\n    if (!elem._initialAttributes) { return; }\n\n    const values = elem._initialAttributes;\n\n    while(elem._n < attributes.length) {\n        if (values[attributes[elem._n]] !== undefined && handlers[attributes[elem._n]]) {\n            handlers[attributes[elem._n]].call(elem, values[attributes[elem._n]]);\n        }\n        ++elem._n;\n    }\n\n    delete elem._initialAttributes;\n    delete elem._n;\n}\n\nfunction hasPropertyAttribute(option) {\n    return !!option.attribute;\n}\n\nfunction hasPropertyDefinition(option) {\n    return option.set || option.get || option.hasOwnProperty('value');\n}\n\nfunction groupAttributeProperty(data, entry) {\n    if (hasPropertyAttribute(entry[1])) {\n        data.attributes[entry[0]] = entry[1].attribute;\n    }\n\n    if (hasPropertyDefinition(entry[1])) {\n        data.properties[entry[0]] = entry[1];\n    }\n\n    return data;\n}\n\nexport default function element(definition, lifecycle, api) {\n    const { name, tag } = captureNameTag(definition);\n\n    // Get the element constructor or the base HTMLElement constructor\n    const constructor = typeof tag === 'string' ?\n        getElementConstructor(tag) :\n        HTMLElement ;\n\n    const { attributes, properties } = api ?\n            Object.entries(api).reduce(groupAttributeProperty, {\n                attributes: {}, \n                properties: {}\n            }) :\n        // Support the old way, a single options object with props and lifecycle included\n        lifecycle.properties ?\n            Object.entries(lifecycle.properties).reduce(groupAttributeProperty, {\n                attributes: {}, \n                properties: {}\n            }) :\n        nothing ;\n\n    function Element() {\n        // Construct an instance from Constructor using the Element prototype\n        const elem   = Reflect.construct(constructor, arguments, Element);\n        const shadow = lifecycle.construct && lifecycle.construct.length > shadowParameterIndex ?\n            createShadow(elem, lifecycle) :\n            undefined ;\n\n        // Get access to the internal form control API\n        const internals = Element.formAssociated && attachInternals(elem) ;\n\n        if (tag) {\n            supportsCustomisedBuiltIn = true;\n        }\n\n        lifecycle.construct && lifecycle.construct.call(elem, shadow, internals);\n\n        // Preserve initialisation order of attribute initialisation by\n        // queueing them\n        if (attributes) {\n            primeAttributes(elem);\n\n            // Wait a tick to flush attributes\n            Promise.resolve(1).then(function() {\n                flushAttributes(elem, Element.observedAttributes, attributes);\n            });\n        }\n\n        // At this point, if properties have already been set before the\n        // element was upgraded, they exist on the elem itself, where we have\n        // just upgraded it's protytype to define those properties those\n        // definitions will never be reached. Either:\n        //\n        // 1. Define properties on the instance instead of the prototype\n        //    Object.defineProperties(elem, properties);\n        //\n        // 2. Take a great deal of care not to set properties before an element\n        //    is upgraded. I can't impose a restriction like that.\n        //\n        // 3. Copy defined properties to their prototype handlers and delete\n        //    them on the instance.\n        //\n        // Let's go with 3. I'm not happy you have to do this, though.\n        properties\n        && Object.keys(properties).reduce(transferProperty, elem);\n\n        return elem;\n    }\n\n\n    // Properties\n    //\n    // Must be defined before attributeChangedCallback, but I cannot figure out\n    // why. Where one of the properties is `value`, the element is set up as a\n    // form element.\n    Element.prototype = Object.create(constructor.prototype, properties) ;\n\n\n    // Form properties\n\n    if (properties && properties.value) {\n        // Flag the Element class as formAssociated\n        Element.formAssociated = true;\n        \n        // Define standard form properties\n        define(Element.prototype, formProperties);\n    \n        if (lifecycle.enable || lifecycle.disable) {\n            Element.prototype.formDisabledCallback = function(disabled) {\n                return disabled ?\n                    lifecycle.disable && lifecycle.disable.call(this, this[$shadow], this[$internals]) :\n                    lifecycle.enable && lifecycle.enable.call(this, this[$shadow], this[$internals]) ;\n            };\n        }\n        \n        if (lifecycle.reset) {\n            Element.prototype.formResetCallback = function() {\n                return lifecycle.reset.call(this, this[$shadow], this[$internals]);\n            };\n        }\n        \n        if (lifecycle.restore) {\n            Element.prototype.formStateRestoreCallback = function() {\n                return lifecycle.restore.call(this, this[$shadow], this[$internals]);\n            };\n        }\n    }\n\n\n    // Attributes\n\n    if (attributes) {\n        Element.observedAttributes = Object.keys(attributes);\n\n        Element.prototype.attributeChangedCallback = function(name, old, value) {\n            if (!this._initialAttributes) {\n                return attributes[name].call(this, value) ;\n            }\n\n            // Keep a record of attribute values to be applied in\n            // observedAttributes order\n            this._initialAttributes[name] = value;\n            advanceAttributes(this, Element.observedAttributes, attributes);\n        };\n    }\n\n\n    // Lifecycle\n\n    Element.prototype.connectedCallback = function() {\n        const elem      = this;\n        const shadow    = elem[$shadow];\n        const internals = elem[$internals];\n\n        // Initialise any attributes that appeared out of order\n        if (elem._initialAttributes) {\n            flushAttributes(elem, Element.observedAttributes, attributes);\n        }\n\n        // If we have simulated form internals, append the hidden input now\n        //if (elem[$internals] && !elem.attachInternals) {\n        //    elem.appendChild(elem[$internals].input);\n        //}\n\n        // If this is the first connect and there is an lifecycle.load fn,\n        // _initialLoad is true\n        if (elem._initialLoad) {\n            const links = shadow.querySelectorAll('link[rel=\"stylesheet\"]');\n\n            if (links.length) {\n                let count  = 0;\n                let n = links.length;\n\n                const load = function load(e) {\n                    if (++count >= links.length) {\n                        // Delete _initialLoad. If the element is removed\n                        // and added to the DOM again, stylesheets do not load\n                        // again\n                        delete elem._initialLoad;\n                        if (lifecycle.load) {\n                            log('element()', 'loaded', Array.from(links).map((link) => link.href).join('\\n'));\n                            lifecycle.load.call(elem, shadow);\n                        }\n                    }\n                };\n\n                const error = window.DEBUG ? function error(e) {\n                    console.error('Failed to load stylesheet', e.target.href);\n                    load(e);\n                } :\n                load ;\n\n                while (n--) {\n                    links[n].addEventListener('load', load, onceEvent);\n                    links[n].addEventListener('error', error, onceEvent);\n                }\n\n                lifecycle.connect && lifecycle.connect.call(this, shadow, internals);\n            }\n            else {\n                lifecycle.connect && lifecycle.connect.call(this, shadow, internals);\n                lifecycle.load    && lifecycle.load.call(this, shadow, internals);\n            }\n        }\n        else {\n            lifecycle.connect && lifecycle.connect.call(this, shadow, internals);\n        }\n    }\n\n    if (lifecycle.disconnect) {\n        Element.prototype.disconnectedCallback = function() {\n            return lifecycle.disconnect.call(this, this[$shadow], this[$internals]);\n        };\n    }\n\n    log('element()', '<' + (tag ? tag + ' is=' + name + '' : name) + '>');\n\n    window.customElements.define(name, Element, tag && { extends: tag });\n\n    // Where tag is supplied, element should have been registered as a customised \n    // built-in and the constructor would have run if any were in the DOM already.\n    // However, Safari does not support customised built-ins. Here we attempt to \n    // go some way towards filling in support by searching for elements and \n    // assigning their intended APIs to them.\n    if (tag && !supportsCustomisedBuiltIn) {\n        if (window.DEBUG) {\n            console.warn('Browser does not support customised built-in elements.\\nAttempting to partially polyfill instances of <' + tag + ' is=\"' + name + '\"> found in the DOM.');\n        }\n\n        document.querySelectorAll('[is=\"' + name + '\"]').forEach((element) => {\n            // Define properties on element\n            define(element, properties);\n\n            // Run constructor\n            lifecycle.construct && lifecycle.construct.apply(element);\n\n            // Detect and run attributes\n            let name;\n            for (name in attributes) {\n                const attribute = element.attributes[name];\n                if (attribute) {\n                    attributes[name].call(element, attribute.value);\n                }\n            }\n\n            lifecycle.connect && lifecycle.connect.apply(element);\n        });\n    }\n\n    return Element;\n}\n", "\n/**\ncreateBoolean(definition)\nCreates an boolean attribute/property definition for element(), where\n`definition` is an object with the functions:\n\n```js\n{\n    enable: fn,\n    disable: fn,\n    getState: fn\n}\n```\n**/\n\nexport default function createBoolean(definition) {\n    function update(element, state) {\n        if (definition.getState(element) === state) { return; }\n        return definition[state ? 'enable' : 'disable'](element);\n    }\n\n    return {\n        attribute: function(value) {\n            return update(this, value !== null);\n        },\n\n        set: function(value) {\n            return update(this, !!value);\n        },\n\n        get: function() {\n            return definition.getState(this);\n        }\n    };\n}\n", "/**\nremove(array, value)\nRemove `value` from `array`. Where `value` is not in `array`, does nothing.\n**/\n\nimport curry from './curry.js';\n\nexport function remove(array, value) {\n    if (array.remove) { array.remove(value); }\n\n    let i;\n    while ((i = array.indexOf(value)) !== -1) {\n        array.splice(i, 1);\n    }\n\n    // Todo: should return array so can be used as reducer. Hook up remove() in \n    // Literal > renderer.js when you do\n    return value;\n}\n\nexport default curry(remove, true);\n", "\nimport { remove } from '../../../fn/modules/remove.js';\n\nconst A      = Array.prototype;\nconst assign = Object.assign;\n\n\n/*\nupdateList(list, tokens)\nThe missing update function for TokenLists. Compares existing tokens with\na new list of tokens, removes those that are not in the new list, and adds\nthose that do not exist.\n*/\n\nfunction updateList(list, tokens) {\n    const removes = list.tokens.slice();\n    const adds    = A.slice.apply(tokens);\n\n    let n = removes.length;\n    while (n--) {\n        if (adds.includes(removes[n])) {\n            removes.splice(n, 1);\n        }\n    }\n\n    list.remove.apply(list, removes);\n    list.add.apply(list, adds);\n}\n\n\n/*\nTokenList(element, definitions)\nThe definitions object is a map of accepted tokens, each one represented by an\nobject with the functions `enable()` and `disable()`.\n*/\n\nfunction TokenList(element, definitions) {\n    this.element     = element;\n    this.definitions = definitions;\n    this.tokens      = [];\n}\n\nassign(TokenList.prototype, {\n    add: function() {\n        let n = arguments.length;\n        while (n--) {\n            const token = arguments[n];\n            if (!this.tokens.includes(token) && this.definitions[token]) {\n                // Call the definition.add() with element as context\n                this.definitions[token].enable(this.element);\n                this.tokens.push(token);\n            }\n        }\n    },\n\n    remove: function() {\n        let n = arguments.length;\n        while (n--) {\n            const token = arguments[n];\n            if (this.tokens.includes(token)) {\n                // Call the definition.remove() with element as context\n                this.definitions[token].disable(this.element);\n                remove(this.tokens, token);\n            }\n        }\n    },\n\n    supports: function(token) {\n        return !!this.definitions[token];\n    }\n});\n\n\n/**\ncreateTokenList(definitions)\nCreates a token list attribute/property definition ready for element(), where\n`definitions` is an object of named token definitions of the form:\n\n```js\n{\n    tokenName: {\n        enable: fn,\n        disable: fn,\n        getState: fn\n    },\n\n    ...\n}\n```\n**/\n\nexport default function createTokenList(definitions) {\n    // We lazily create a TokenList as needed, not so much for efficacy, but\n    // because we don't have a reference to element until the attribute or\n    // property is accessed.\n    var list;\n\n    function update(element, string) {\n        list = list || new TokenList(element, definitions);\n        updateList(list, string.trim().split(/\\s+/));\n    }\n\n    return {\n        attribute: function(value) {\n            update(this, value || '');\n        },\n\n        set: function(value) {\n            update(this, value + '');\n        },\n\n        get: function() {\n            list = list || new TokenList(this, definitions);\n            return list;\n        }\n    };\n}\n", "\nimport Stream   from '../../fn/modules/stream.js';\nimport Producer from '../../fn/modules/stream/producer.js';\n//import features from './features.js';\n\nconst assign  = Object.assign;\nconst rspaces = /\\s+/;\n\n/*\nfunction prefixType(type) {\n\treturn features.events[type] || type ;\n}\n*/\n\n/**\nisPrimaryButton(e)\nReturns `true` if event is from the primary (normally the left or only)\nbutton of an input device. Use this to filter out right-clicks.\n*/\n\nexport function isPrimaryButton(e) {\n\t// Ignore mousedowns on any button other than the left (or primary)\n\t// mouse button, or when a modifier key is pressed.\n\treturn (e.which === 1 && !e.ctrlKey && !e.altKey && !e.shiftKey);\n}\n\n/**\npreventDefault(e)\nCalls `e.preventDefault()`.\n**/\n\nexport function preventDefault(e) {\n\te.preventDefault();\n}\n\n/**\nisTargetEvent(e)\nTests whether `e.target === e.currentTarget`.\n**/\nexport function isTargetEvent(e) {\n\treturn e.target === e.currentTarget;\n}\n\nexport function isNotPrevented(e) {\n\treturn !e.defaultPrevented;\n}\n\n\n\n/**\nevents(type, node)\n\nReturns a mappable stream of events heard on `node`:\n\n```js\nvar stream = events('click', document.body);\n.map(get('target'))\n.each(function(node) {\n    // Do something with nodes\n});\n```\n\nStopping the stream removes the event listeners:\n\n```js\nstream.stop();\n```\n\nThe first parameter may also be an options object, which must have a `type`\nproperty. The `select: '...'` property allows for delegation of an event from\nthe selected target. Other properties, eg. `passive: true` are passed to\naddEventListener options.\n\n```js\nvar stream = events({ type: 'scroll', passive: true, select: '' }, document.body);\n```\n*/\n\n// DOM click events may be simulated on inputs when their labels are\n// clicked. The tell-tale is they have the same timeStamp. Track click\n// timeStamps.\nvar clickTimeStamp = 0;\n\nwindow.addEventListener('click', (e) => clickTimeStamp = e.timeStamp);\n\nfunction listen(listener, type) {\n    listener.node.addEventListener(type, listener, listener.options);\n    return listener;\n}\n\nfunction unlisten(listener, type) {\n    listener.node.removeEventListener(type, listener);\n    return listener;\n}\n\nfunction EventsProducer(type, options, node) {\n    this.types   = type.split(rspaces);//.map(prefixType);\n    this.options = options;\n    this.node    = node;\n    this.select  = options && options.select;\n\n    // Potential hard-to-find error here if type has repeats, ie 'click click'.\n    // Lets assume nobody is dumb enough to do this, I dont want to have to\n    // check for that every time.\n}\n\nassign(EventsProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        this[0] = stream;\n        this.types.reduce(listen, this);\n    },\n\n    handleEvent: function(e) {\n        // Ignore clicks with the same timeStamp as previous clicks –\n        // they are likely simulated by the browser.\n        if (e.type === 'click' && e.timeStamp <= clickTimeStamp) {\n            return;\n        }\n\n        // If there is a selector and the target doesn't match, shoofty\n        // outta here\n        if (this.select) {\n            const selectedTarget = e.target.closest(this.select);\n            if (!selectedTarget) { return; }\n            e.selectedTarget = selectedTarget;\n        }\n\n        this[0].push(e);\n    },\n\n    stop: function() {\n        this.types.reduce(unlisten, this);\n        Producer.prototype.stop.apply(this, arguments);\n    }\n});\n\nexport default function events(type, node) {\n    let options;\n\n    if (typeof type === 'object') {\n        options = type;\n        type    = options.type;\n    }\n\n    return new Stream(new EventsProducer(type, options, node));\n}\n\n\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n\twindow.dom ? (window.dom.events = events) : (window.dom = { events });\n}\n\n", "\n/**\nget(name, object)\nGet property `name` of `object`.\n*/\n\nimport curry from './curry.js';\n\nexport function get(key, object) {\n    // Todo? Support WeakMaps and Maps and other map-like objects with a\n    // get method - but not by detecting the get method\n    return object[key];\n}\n\nexport default curry(get, true);\n", "/**\ntoType(object)\nReturns `typeof object`.\n*/\n\nexport default function toType(object) {\n    return typeof object;\n}\n", "import curry from './curry.js';\n\n/**\nparseValue(units, string)\n\nParse `string` as a value with a unit (such as `\"3px\"`). Parameter `units` is an\nobject of functions keyed by the unit postfix. It may also have a `catch`\nfunction.\n\n```js=\nconst value = parseValue({\n    px: function(n) {\n        return n;\n    },\n\n    catch: function(string) {\n        if (typeof string === 'number') {\n            return string;\n        }\n\n        throw new Error('Cannot parse px value');\n    }\n}, '36px');\n```\n**/\n\n// Be generous in what we accept, space-wise, but exclude spaces between the \n// number and the unit\nconst runit = /^\\s*([+-]?\\d*\\.?\\d+)([^\\s\\d]*)\\s*$/;\n\nexport function parseValue(units, string) {\n    // Allow number to pass through\n    if (typeof string === 'number') {\n        return string;        \n    }\n\n    var entry = runit.exec(string);\n\n    if (!entry || !units[entry[2] || '']) {\n        if (!units.catch) {\n            throw new Error('Cannot parse value \"' + string + '\" with provided units ' + Object.keys(units).join(', '));\n        }\n\n        return entry ?\n            units.catch(parseFloat(entry[1]), entry[2]) :\n            units.catch(parseFloat(string)) ;\n    }\n\n    return units[entry[2] || ''](parseFloat(entry[1]));\n}\n\nexport default curry(parseValue);\n", "/**\nstyle(property, node)\n\nReturns the computed style `property` of `node`.\n\n    style('transform', node);            // returns transform\n\nIf `property` is of the form `\"property:name\"`, a named aspect of the property\nis returned.\n\n    style('transform:rotate', node);     // returns rotation, as a number, in radians\n    style('transform:scale', node);      // returns scale, as a number\n    style('transform:translateX', node); // returns translation, as a number, in px\n    style('transform:translateY', node); // returns translation, as a number, in px\n*/\n\nvar rpx          = /px$/;\nvar styleParsers = {\n\t\"transform:translateX\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\treturn parseFloat(values[4]);\n\t},\n\n\t\"transform:translateY\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\treturn parseFloat(values[5]);\n\t},\n\n\t\"transform:scale\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\tvar a = parseFloat(values[0]);\n\t\tvar b = parseFloat(values[1]);\n\t\treturn Math.sqrt(a * a + b * b);\n\t},\n\n\t\"transform:rotate\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\tvar a = parseFloat(values[0]);\n\t\tvar b = parseFloat(values[1]);\n\t\treturn Math.atan2(b, a);\n\t}\n};\n\nfunction valuesFromCssFn(string) {\n\treturn string.split('(')[1].split(')')[0].split(/\\s*,\\s*/);\n}\n\nfunction computedStyle(name, node) {\n\treturn window.getComputedStyle ?\n\t\twindow\n\t\t.getComputedStyle(node, null)\n\t\t.getPropertyValue(name) :\n\t\t0 ;\n}\n\nexport default function style(name, node) {\n    // If name corresponds to a custom property name in styleParsers...\n    if (styleParsers[name]) { return styleParsers[name](node); }\n\n    var value = computedStyle(name, node);\n\n    // Pixel values are converted to number type\n    return typeof value === 'string' && rpx.test(value) ?\n        parseFloat(value) :\n        value ;\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { style });\n}\n", "// Units\n\nimport id         from '../../fn/modules/id.js';\nimport overload   from '../../fn/modules/overload.js';\nimport toType     from '../../fn/modules/to-type.js';\nimport parseValue from '../../fn/modules/parse-value.js';\nimport style      from './style.js';\n\n\n/* Track document font size */\n\nlet emSize;\nlet remSize;\n\nfunction getEmSize() {\n    if (!emSize) {\n        if (window.DEBUG) {\n            console.warn('Calculating root em value may cause reflow as user font-size cannot be known without setting <html style=\"font-size: 100%;\">');\n        }\n\n        const styledFontSize = document.documentElement.style.fontSize;\n        document.documentElement.style.fontSize = '100%';\n        emSize = style(\"font-size\", document.documentElement);\n        document.documentElement.style.fontSize = styledFontSize || '';\n    }\n\n    return emSize;\n}\n\nfunction getRemSize() {\n    if (!remSize) {\n        remSize = style(\"font-size\", document.documentElement);\n    }\n\n    return remSize;\n}\n\nwindow.addEventListener('resize', () => {\n    emSize  = undefined;\n    remSize = undefined;\n});\n\n/**\npx(value)\nTakes a number in pixels or a string of the form `'10px'`, `'10em'`, `'10rem'`,\n`'100vw'`, `'100vh'`, `'100vmin'` or `'100vmax'`, and returns a numeric value\nin pixels.\n*/\n\nexport const px = overload(toType, {\n    'number': id,\n\n    'string': parseValue({\n        em: function(n) {\n            return getEmSize() * n;\n        },\n\n        px: function(n) {\n            return n;\n        },\n\n        rem: function(n) {\n            return getRemSize() * n;\n        },\n\n        vw: function(n) {\n            return window.innerWidth * n / 100;\n        },\n\n        vh: function(n) {\n            return window.innerHeight * n / 100;\n        },\n\n        vmin: function(n) {\n            return window.innerWidth < window.innerHeight ?\n                window.innerWidth * n / 100 :\n                window.innerHeight * n / 100 ;\n        },\n\n        vmax: function(n) {\n            return window.innerWidth < window.innerHeight ?\n                window.innerHeight * n / 100 :\n                window.innerWidth * n / 100 ;\n        }\n    })\n});\n\nexport default px;\n\n/**\nem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `em`, eg. `0.625`. Depends on the user defined browser\n`font-size`.\n*/\n\nexport function em(n) {\n    return px(n) / getEmSize();\n}\n\n/**\nrem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `rem`, eg. `0.625`. Depends on the `font-size` of the\ndocumentElement.\n*/\n\nexport function rem(n) {\n    return px(n) / getRemSize();\n}\n\n/**\nvw(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vw`, eg. `120`. Depends on the width of the viewport at\nrender time.\n*/\n\nexport function vw(n) {\n    return 100 * px(n) / window.innerWidth;\n}\n\n/**\nvh(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vh`, eg. `120`. Depends on the height of the viewport at\nrender time.\n*/\n\nexport function vh(n) {\n    return 100 * px(n) / window.innerHeight;\n}\n\n/**\nvmin(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmin`, eg. `120`. Depends on the minimum dimension of the\nviewport at render time.\n*/\n\nexport function vmin(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerWidth :\n            window.innerHeight\n    );\n}\n\n/**\nvmax(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmax`, eg. `120`. Depends on the maximum dimension of the\nviewport at render time.\n*/\n\nexport function vmax(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerHeight :\n            window.innerWidth\n    );\n}\n\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { px, em, rem, vw, vh, vmin, vmax });\n}\n", "\n/**\ngestures(options, node)\n\nReturns a stream of streams of events. Each stream of events represents the\nmotion of a single finger. The types of events the stream contains is a\n`'pointerdown'` followed by any number of `'pointermove'`s and a `'pointerup'`\nor `'pointercancel'` event.\n\n```js\ngestures({ selector: '.thing', threshold: '0.5rem', device: 'mouse pen touch' }, document)\n.each(function(events) {\n    const e0 = events.shift();\n\n    events.each(function(e1) {\n        const distance = Math.pow(\n            Math.pow(e1.clientX - e0.clientX, 2),\n            Math.pow(e1.clientY - e0.clientY, 2),\n        0.5);\n\n        console.log(distance);\n    });\n});\n```\n\nThe `options` object may optionally contain any of:\n\n```js\n{\n    // Listen to gestures on a given device type. Internally the pointer events'\n    // e.pointerType is matched against this string: it may contain any of the\n    // types 'pen', 'mouse' and 'touch'. Where not defined, all pointer types\n    // trigger a gesture\n    device: 'mouse pen',\n\n    // Listen to gestures inside a selected element or elements\n    selector: '.class'\n\n    // Determine a minimum distance a finger must travel before a gesture is\n    // considered to have started\n    threshold: '0.25rem'\n}\n```\n*/\n\nimport get      from '../../fn/modules/get.js';\nimport overload from '../../fn/modules/overload.js';\nimport Stream   from '../../fn/modules/stream.js';\nimport Producer from '../../fn/modules/stream/producer.js';\nimport px       from './parse-length.js';\n\nconst assign = Object.assign;\n\nexport const config = {\n    // Number of pixels, or string CSS length, that a pressed pointer travels\n    // before gesture is started.\n    threshold: 4,\n\n    ignoreTags: {\n        textarea: true,\n        input: true,\n        select: true\n    }\n};\n\n\n/* Pointermove, pointerup and pointercancel handler */\n\nfunction checkThreshold(threshold, e0, e1) {\n    var distX = e1.clientX - e0.clientX;\n    var distY = e1.clientY - e0.clientY;\n\n    // Return false if the threshold has not been crossed.\n    return !(\n        (distX * distX) + (distY * distY) < (threshold * threshold)\n    );\n}\n\nfunction Pointermove(stream, events, options) {\n    this.stream    = stream;\n    this.events    = events;\n    this.options   = options;\n    this.pointerId = events[0].pointerId;\n    this.threshold = px(options.threshold);\n\n    document.addEventListener('pointermove', this);\n    document.addEventListener('pointerup', this);\n    document.addEventListener('pointercancel', this);\n\n    // If threshold is 0 start gesture immediately\n    if (this.threshold === 0) {\n        this.createGesture();\n    }\n}\n\nassign(Pointermove.prototype, {\n    handleEvent: overload(get('type'), {\n        'pointermove': function(e) {\n            if (this.pointerId !== e.pointerId) {\n                console.log('Not the same pointer');\n                return;\n            }\n\n            this.events.push(e);\n\n            // Before we cross the threshold we need to check it on each move\n            if (!this.isGesture && checkThreshold(this.threshold, this.events[0], e)) {\n                this.createGesture();\n            }\n\n            // After we want to cancel any default actions\n            else {\n                e.preventDefault();\n            }\n        },\n\n        'default': function(e) {\n            if (this.pointerId !== e.pointerId) {\n                console.log('Not the same pointer');\n                return;\n            }\n\n            this.events.push(e);\n            this.stop();\n        }\n    }),\n\n    createGesture: function() {\n        this.isGesture = true;\n\n        // Have a buffer stream take over as the events buffer\n        // TODO! There's a bug here - buffer stream does not use .push() to fill its buffer!!\n        // TODO! Also, you can't .stop() this.events, things still get pushed to it. Clearly we\n        // need a proper producer!\n        this.events = Stream.from(this.events);\n        this.stream.push(this.events);\n    },\n\n    stop: function() {\n        // Stop the gesture stream\n        this.events.stop && this.events.stop();\n\n        // Remove the listeners\n        document.removeEventListener('pointermove', this);\n        document.removeEventListener('pointerup', this);\n        document.removeEventListener('pointercancel', this);\n    }\n});\n\n\n/* Pointerdown handler */\n\nfunction isIgnoreTag(e) {\n    var tag = e.target.tagName;\n    return tag && (!!config.ignoreTags[tag.toLowerCase()] || e.target.draggable);\n}\n\nfunction PointerProducer(node, options) {\n    this.node    = node;\n    this.options = options;\n    this.node.addEventListener('pointerdown', this);\n}\n\nassign(PointerProducer.prototype, Producer.prototype, {\n    handleEvent: function(e) {\n        // Ignore non-primary buttons\n        if (e.button !== 0) { return; }\n\n        // Check pointer type is in options\n        if (this.options.device && !this.options.device.includes(e.pointerType)) { return; }\n\n        // Ignore form and interactive elements\n        if (isIgnoreTag(e)) { return; }\n\n        // Check target matches selector\n        if (this.options.selector && !e.target.closest(this.options.selector)) { return; }\n\n        // Copy event to keep the true target around, as target is mutated on\n        // the event if it passes through a shadow boundary after being handled\n        // here, resulting in a rare but gnarly bug hunt.\n        var event = {\n            type:          e.type,\n            target:        e.target,\n            currentTarget: e.currentTarget,\n            clientX:       e.clientX,\n            clientY:       e.clientY,\n            timeStamp:     e.timeStamp,\n            pointerId:     e.pointerId\n        };\n\n        new Pointermove(this[0], [event], this.options);\n    },\n\n    // Stop the gestures stream\n    stop: function() {\n        this.node.removeEventListener('pointerdown', this);\n        Producer.prototype.stop.apply(this, arguments);\n    }\n});\n\n\n/* Gestures */\n\nexport default function gestures(options, node) {\n    options = node ?\n        options ? assign({}, config, options) : config :\n        config ;\n\n    node = node ?\n        node :\n        options ;\n\n    return new Stream(new PointerProducer(node, options));\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { gestures });\n}\n", "\n// Much of this code has been purloined from targetable.js – do we need the\n// hashchange tracking here? I have commented it\n\nimport Stream   from '../../fn/modules/stream.js';\nimport Producer from '../../fn/modules/stream/producer.js';\n\nconst assign = Object.assign;\n\nconst captureOptions = {\n    capture: true,\n    passive: true\n};\n\n/*\nConfig\n*/\n\nexport const config = {\n    minScrollEventInterval: 0.0375,\n    maxScrollEventInterval: 0.18\n};\n\n// Capture scroll events in capture phase, as scroll events from elements\n// other than document do not bubble.\n\nvar trackingInterval = config.maxScrollEventInterval;\n\nfunction adjustTrackingInterval(times) {\n    // Dynamically adjust maxScrollEventInterval to tighten it up,\n    // imposing a baseline of 60ms (0.0375s * 1.6)\n\n    let n = times.length;\n    let interval = 0;\n\n    while (--n) {\n        const t = times[n] - times[n - 1];\n        interval = t > interval ? t : interval;\n    }\n\n    interval = interval < config.minScrollEventInterval ?\n        config.minScrollEventInterval :\n        interval ;\n\n    trackingInterval =  (1.4 * interval) > config.maxScrollEventInterval ?\n        config.maxScrollEventInterval :\n        (1.4 * interval) ;\n}\n\nfunction update(source, e) {\n    const { times } = source;\n\n    source.value.stop();\n    source.value = undefined;\n\n    if (times.length > 1) {\n        adjustTrackingInterval(times);\n    }\n\n    times.length = 0;\n}\n\nfunction ScrollsProducer(element) {\n    this.element = element;\n    this.times   = [];\n}\n\nassign(ScrollsProducer.prototype, Producer.prototype, {\n    pipe: function(stream) {\n        this.stream = stream;\n\n        // Method may be used once only\n        //if (window.DEBUG) { this.start = startError; }\n\n        /*\n        window.addEventListener('hashchange', function hashchange(e) {\n            hashtime = e.timeStamp / 1000;\n            //console.log('hashchange', hashtime, window.location.hash);\n        });\n        */\n\n        this.element.addEventListener('scroll', this, captureOptions);\n    },\n\n    handleEvent: function(e) {\n        // Ignore the first scroll event following a hashchange. The browser sends a\n        // scroll event even where a target cannot be scrolled to, such as a\n        // navigation with position: fixed, for example. This can cause targetable\n        // to recalculate again, and shift the target back to one fo the targetables,\n        // where it should stay on the navigation element.\n        const time = e.timeStamp / 1000;\n\n        // Make sure this only happens once after a hashchange\n        /*if (hashtime !== undefined) {\n            // If we are not mid-scroll, and the latest hashchange was less than\n            // 0.1s ago, ignore\n            if (!times.length && hashtime > time - 0.1) {\n                //console.log('scroll', 'ignored');\n                hashtime = undefined;\n                return;\n            }\n\n            hashtime = undefined;\n        }*/\n\n        this.times.push(time);\n\n        if (this.value) {\n            clearTimeout(this.timer);\n            this.value.push(e);\n        }\n        else {\n            this.value = Stream.of(e);\n            this.stream.push(this.value);\n        }\n\n        // Update only when there is a trackingInterval second pause in scrolling\n        this.timer = setTimeout(update, trackingInterval * 1000, this, e);\n    },\n\n    stop: function() {\n        this.element.removeEventListener('scroll', this);\n        Producer.prototype.stop.apply(this, arguments);\n    }\n});\n\nexport default function scrolls(element) {\n    return new Stream(new ScrollsProducer(element));\n}\n", "\nexport const $data = Symbol('data');\n", "\n/**\ntrigger(type, node)\n\nTriggers event of `type` on `node`. Returns `false` if the event default was\nprevented, otherwise `true`.\n\n```\ntrigger('dom-activate', node);\n```\n*/\n\n/**\ntrigger(event, node)\n\nTriggers an event described by `event` on `node`. The `event` object must have a\n`type` property. The `details` property can be used to carry a payload. The\noptions `bubbles`, `cancelable` and `composed` determine the behaviour of the\nevent. All other properties are assigned as properties on the event.\n\n```\ntrigger({\n    type: 'dom-activate',\n    detail: {...},\n    bubbles:    true,\n    cancelable: true,\n    composed:   false\n}, node);\n```\n\nReturns `false` if the event default was prevented, otherwise `true`.\n*/\n\nimport curry from '../../fn/modules/curry.js';\n\nconst assign   = Object.assign;\n\nconst defaults = {\n    // The event bubbles (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n    bubbles: true,\n\n    // The event may be cancelled (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n    cancelable: true\n\n    // Trigger listeners outside of a shadow root (false by default)\n    // https://developer.mozilla.org/en-US/docs/Web/API/Event/composed\n    //composed: false\n};\n\nexport function trigger(type, node) {\n    let options = defaults;\n    let properties, detail, bubbles, cancelable, composed, event;\n\n    if (typeof type === 'object') {\n        ({ type, detail, bubbles, cancelable, composed, ...properties } = type);\n\n        // Options accepted by CustomEvent:\n        // detail:     any\n        // bubbles:    true | false\n        // cancelable: true | false\n        // composed:   true | false\n        // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n        event = assign(new CustomEvent(type, {\n            detail,\n            bubbles:    bubbles    || defaults.bubbles,\n            cancelable: cancelable || defaults.cancelable,\n            composed:   composed   || defaults.composed\n        }), properties);\n    }\n    else {\n        event = new CustomEvent(type, defaults);\n    }\n\n    return node.dispatchEvent(event);\n}\n\nexport default curry(trigger, true);\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { trigger });\n}\n", "\n/*\nDetect and scroll to active slides. The active is the slide currently in\nscroll-snap alignment.\n*/\n\nimport { px }      from '../../dom/modules/parse-length.js';\nimport rect        from '../../dom/modules/rect.js';\nimport { trigger } from '../../dom/modules/trigger.js';\n\n\nfunction getPaddedBox(scroller) {\n    const box          = rect(scroller);\n    const computed     = window.getComputedStyle(scroller, null);\n    const paddingLeft  = px(computed.getPropertyValue('padding-left'));\n    const paddingRight = px(computed.getPropertyValue('padding-right'));\n\n    box.leftPadding   = box.left + paddingLeft;\n    box.rightPadding  = box.left + box.width - paddingRight;\n    box.centrePadding = box.leftPadding + (box.width - paddingLeft - paddingRight) / 2;\n\n    return box;\n}\n\nfunction getSnapX(element) {\n    // Todo: do we need webkit property here?\n    const snap = window\n        .getComputedStyle(element, null)\n        .getPropertyValue('scroll-snap-align');\n\n    // Imagine a detection line half a slides' width to the right of\n    // the left, the centre, or the right...\n    return snap.endsWith('start') ? 'left' :\n        snap.endsWith('end')   ? 'right' :\n        'centre' ;\n}\n\nfunction scrollToTarget(scroller, target, behavior) {\n    const scrollerBox = getPaddedBox(scroller);\n    const targetBox   = rect(target);\n    const snap        = getSnapX(target);\n\n    // Move scroll position to target slide, taking into account\n    // scroll-snap-align of the slide\n    scroller.scrollTo({\n        top:  scroller.scrollTop,\n        left: scroller.scrollLeft + (\n            snap === 'left' ? targetBox.left - scrollerBox.leftPadding :\n            snap === 'right' ? targetBox.right - scrollerBox.rightPadding :\n            targetBox.left + (targetBox.width / 2) - scrollerBox.centrePadding\n        ),\n        behavior: behavior\n    });\n}\n\nexport function scrollTo(scroller, target, behavior) {\n    scrollToTarget(scroller, target, 'smooth');\n}\n\nexport function jumpTo(scroller, target) {\n    scroller.style.setProperty('scroll-behavior', 'auto', 'important');\n    scrollToTarget(scroller, target, 'auto');\n    scroller.style.setProperty('scroll-behavior', '');\n}\n\nfunction getActive(scroller, children) {\n    const { leftPadding, rightPadding, centrePadding } = getPaddedBox(scroller);\n\n    let n = children.length;\n    let slide;\n\n    while ((slide = children[--n])) {\n        const slideRect = rect(slide);\n        if (!slideRect) { continue; }\n\n        // Todo: do we need webkit property here?\n        const snap = getSnapX(slide);\n\n        // Imagine a detection line half a slides' width to the right of\n        // the left, the centre, or the right...\n        const detection = (slideRect.width / 2) + (\n            snap === 'left' ? leftPadding :\n            snap === 'right' ? rightPadding :\n            centrePadding\n        );\n\n        // ...and a slide registration position at it's corresponding left,\n        // centre or right position. Safari reports 2 values for\n        // scroll-snap-align it's the second that is the inline axis value\n        const x = snap === 'left' ? slideRect.left :\n            snap === 'right' ? slideRect.right :\n            slideRect.left + slideRect.width / 2 ;\n\n        // If position has crossed the detection going left, we're in the money\n        if (x <= detection) {\n            break;\n        }\n    }\n\n    // Return active slide\n    return slide;\n}\n\nfunction isGhost(slide) {\n    return !!slide.dataset.slideIndex;\n}\n\n/**\n'slide-active'\nEmitted by a slide when it is brought into scroll-snap alignment.\n**/\n\nexport function updateActive(data) {\n    const { scroller, children, elements } = data;\n    const current = getActive(scroller, elements);\n    let active;\n\n    // If current is a loop ghost jump to the actual slide it references\n    if (isGhost(current)) {\n        active = children[current.dataset.slideIndex];\n        jumpTo(scroller, active);\n    }\n    else {\n        active = current;\n    }\n\n    if (active === data.active) { return; }\n    data.active = active;\n    if (active === undefined) { return; }\n    data.actives.push(active);\n    trigger('slide-active', active);\n}\n", "\nimport events   from '../../dom/modules/events.js';\nimport overload from '../../fn/modules/overload.js';\n\nimport { updateActive } from './active.js';\n\nexport const processPointers = overload((data, e) => e.type, {\n    pointerdown: function(data, e) {\n        // First event is touchstart or mousedown\n        data.e0 = e;\n        data.x0 = e.clientX;\n        data.y0 = e.clientY;\n\n        return data;\n    },\n\n    pointermove: function(data, e) {\n        const x1 = e.clientX;\n        const y1 = e.clientY;\n\n        // Determine whether to start a gesture\n        if (!data.gesturing) {\n            // If the movement is more vertical than horizontal, don't count it\n            // as a swipe. Stop the stream and get out of here.\n            if (Math.abs(x1 - data.x0) < Math.abs(y1 - data.y0)) {\n                data.pointers.stop();\n                data.pointers = undefined;\n                data.e0 = undefined;\n                data.x0 = undefined;\n                data.y0 = undefined;\n                return;\n            }\n\n            data.scrollLeft0 = data.scroller.scrollLeft;\n            //data.scroller.classList.add('gesturing');\n            data.scroller.style.setProperty('scroll-snap-type', 'none', 'important');\n            data.scroller.style.setProperty('scroll-behavior', 'auto', 'important');\n            data.gesturing = true;\n        }\n\n        const dx = e.clientX - data.x0;\n        data.scroller.scrollLeft = data.scrollLeft0 - dx;\n\n        return data;\n    },\n\n    // Catches pointerup and pointercancel\n    default: function(data, e) {\n        const scroller = data.scroller;\n\n        // Track the end of click to allow click suppression\n        data.clickSuppressTime = e.timeStamp;\n\n        // Here we must go through a whole rigmarole in an attempt to avoid\n        // scroll jumps at the end of a swipe. Find out where it is, ...\n        const scrollLeft1 = scroller.scrollLeft;\n        scroller.style.setProperty('scroll-snap-type', '');\n\n        // and where it would snap to.\n        const scrollLeft2 = scroller.scrollLeft;\n\n        // If those numbers are the same we are probably in FF, where removing\n        // scroll-snap type doesn't seem to change much.\n        if (scrollLeft1 === scrollLeft2) {\n            // But FF has sensible smooth scroll behaviour, reset it.\n            scroller.style.setProperty('scroll-behavior', '');\n        }\n        else {\n            // We may as well preemptively update the active slide now, since we\n            // are sitting in the new position. This is not a crucial step, just\n            // makes the UI react a bit more quickly.\n            updateActive(data);\n\n            // Otherwise we have to do things the hard way. Switch scroll-snap\n            // off again and put scroll back to position 1, ...\n            scroller.style.setProperty('scroll-snap-type', 'none', 'important');\n            scroller.scrollLeft = scrollLeft1;\n\n            // then manually smooth scroll over to position 2, ...\n            scroller.style.setProperty('scroll-behavior', '');\n            scroller.scrollTo({\n                top:  scroller.scrollTop,\n                left: scrollLeft2,\n                behavior: 'smooth'\n            });\n\n            // and finally, switch scroll snapping back on when that scroll is\n            // over. Wait for two frames without a scroll event to pass before\n            // resetting scroll-snap.\n            let frame;\n            const scrolls = events({ type: 'scroll', passive: true }, scroller).each(() => {\n                cancelAnimationFrame(frame);\n                frame = requestAnimationFrame(() =>\n                    frame = requestAnimationFrame(() => {\n                        scroller.style.setProperty('scroll-snap-type', '');\n                        scrolls.stop();\n                    })\n                );\n            });\n\n            // Ooof. What a polava.\n        }\n\n        data.gesturing = false;\n        data.e0 = undefined;\n        data.x0 = undefined;\n        data.y0 = undefined;\n        data.pointers  = undefined;\n        data.scrollLeft0 = undefined;\n\n        return data;\n    }\n});\n", "\n/*\nAutoplay\n*/\n\nimport id         from '../../fn/modules/id.js';\nimport get        from '../../fn/modules/get.js';\nimport overload   from '../../fn/modules/overload.js';\nimport parseValue from '../../fn/modules/parse-value.js';\nimport Stream     from '../../fn/modules/stream.js';\nimport events     from '../../dom/modules/events.js';\n\nimport { $data }  from './consts.js';\n\nconst parseTime = parseValue({\n    's':  id,\n    'ms': (n) => n / 1000\n});\n\n/*\nTODO: dont autoplay when hidden??\n\nevents('visibilitychange', document).each((e) => {\n    if (document.hidden) {\n\n    }\n    else {\n\n    }\n});\n*/\n\nfunction change(data) {\n    const { active, children, elements, host } = data;\n    const i = elements.indexOf(active);\n    const target = elements[i + 1] || children[0];\n    //console.log('AUTOPLAY CHANGE', target);\n    data.autoplay.timer = null;\n    if (!target) { return; }\n    host.active = target;\n}\n\nfunction update(data) {\n    const { active, style } = data;\n    const duration = parseTime(\n        window\n        .getComputedStyle(active)\n        .getPropertyValue('--slide-duration') ||\n        style.getPropertyValue('--slide-duration')\n    );\n\n    clearTimeout(data.autoplay.timer);\n    //console.log('AUTOPLAY UPDATE', duration);\n    data.autoplay.timer = setTimeout(change, duration * 1000, data);\n}\n\nfunction cancel(data) {\n    //console.log('AUTOPLAY CANCEL');\n    clearTimeout(data.autoplay.timer);\n    data.autoplay.timer = null;\n}\n\nexport function enable(host) {\n    const data = host[$data];\n    const { actives } = data;\n\n    // Add an object to store autoplay state\n    const autoplay = data.autoplay = {};\n\n    // Create a stream of hover states starting with false. Note that this is\n    // an assumption - the cursor may well be in hover state when autoplay is\n    // enabled.\n    const hovers = Stream.merge(\n        [false],\n        events('pointerenter pointerleave', host)\n        .map((e) => e.type === 'pointerenter')\n    );\n\n    // Create a stream of focus inside state\n    const focuses = Stream.merge(\n        [host.contains(document.activeElement)],\n        events('focusin focusout', host)\n        .map(overload(get('type'), {\n            'focusin': (e) => true,\n            'focusout': (e) => host.contains(e.relatedTarget)\n        }))\n    )\n    // Deduplicate\n    .map(((v) => (value) => (v === value ? undefined : (v = value)))());\n\n    // Schedule a change timer on every activate where the user is not\n    // hovering, or at the end of the hover\n    autoplay.updates = Stream\n        .combine({ active: actives, hover: hovers, focus: focuses })\n        .each((state) => (state.hover || state.focus ?\n            cancel(data) :\n            update(data)\n        ));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    cancel(data);\n    data.autoplay.updates.stop();\n    data.autoplay = undefined;\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.autoplay;\n}\n", "\nimport rect from '../../dom/modules/rect.js';\n\nimport { $data }  from './consts.js';\nimport { jumpTo } from './active.js';\n\n\nconst loopOverflow = 2400;\n\n\nfunction toLoopGhost(slide, i) {\n    const ghost = slide.cloneNode(true);\n    ghost.dataset.slideIndex = i;\n    ghost.removeAttribute('id');\n    ghost.setAttribute('aria-hidden', 'true');\n    ghost.tabIndex = '-1';\n    return ghost;\n}\n\nfunction render(data) {\n    const { active, children, host, scroller } = data;\n\n    if (children.length < 2) {\n        return;\n    }\n\n    // Expand children to the left and right by loopOverflow px\n    const boxes = children.map(rect);\n    const left  = boxes[0].left;\n    const right = boxes[boxes.length - 1].right;\n\n    let n = 0;\n    while (boxes[++n] && boxes[n].left < left + loopOverflow);\n    const appends = children.slice(0, n).map(toLoopGhost);\n\n    n = boxes.length - 1;\n    while (boxes[--n] && boxes[n].right > right - loopOverflow);\n    const prepends = children.slice(++n).map((slide, i) => toLoopGhost(slide, n + i));\n\n    host.prepend.apply(host, prepends);\n    host.append.apply(host, appends);\n\n    data.loop.prepends = prepends;\n    data.loop.appends  = appends;\n\n    jumpTo(scroller, active || children[0]);\n}\n\nexport function enable(host) {\n    const data = host[$data];\n    const { mutations } = data;\n\n    // Add an object to store loop state\n    const loop = data.loop = {};\n\n    if (!data.loaded) {\n        return;\n    }\n\n    // Render buttons when children change\n    loop.mutations = mutations\n        .map((o) => o)\n        .each(() => render(data));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    if (data.loop) {\n        data.loop.prepends && data.loop.prepends.forEach((slide) => slide.remove());\n        data.loop.appends  && data.loop.appends.forEach((slide) => slide.remove());\n        data.loop.mutations.stop();\n        data.loop = undefined;\n    }\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.loop;\n}\n", "\nimport create   from '../../dom/modules/create.js';\nimport delegate from '../../dom/modules/delegate.js';\n\nimport { $data }  from './consts.js';\nimport { enableControls } from './controls.js';\n\nfunction updateButtons(prev, next, elements, i) {\n    // Preemptively hide buttons now (before new active is detected at\n    // end of scroll)\n    if (i === 0) {\n        prev.hidden = true;\n    }\n    else {\n        prev.hidden = false;\n    }\n\n    if (i === elements.length - 1) {\n        next.hidden = true;\n    }\n    else {\n        next.hidden = false;\n    }\n}\n\nfunction update(data) {\n    const { active, elements, navigation: { prev, next } } = data;\n    const i = elements.indexOf(active);\n    updateButtons(prev, next, elements, i)\n}\n\nexport function enable(host) {\n    const data = host[$data];\n    const { actives, clicks, mutations } = data;\n\n    // Set up nav::part(controls) element\n    enableControls(data);\n\n    // Add an object to store navigation state\n    const navigation = data.navigation = {\n        prev: create('button', { part: 'prev-button', type: \"button\", name: \"navigation\", value: \"-1\", html: 'Previous' }),\n        next: create('button', { part: 'next-button', type: \"button\", name: \"navigation\", value: \"1\", html: 'Next' })\n    };\n\n    data.controls.prepend(navigation.prev, navigation.next);\n\n    // Add object for storing navigation state\n    navigation.mutations = mutations.each(() => update(data));\n\n    // Create a new stream of actives starting with the current active\n    navigation.actives = actives.each(() => update(data));\n\n    navigation.clicks = clicks.each(delegate({\n        '[name=\"navigation\"]': function(button, e) {\n            const value  = parseFloat(button.value);\n            const i      = data.elements.indexOf(data.active) + value;\n            const target = data.elements[i];\n\n            if (!target) { return; }\n\n            host.active = target;\n            updateButtons(navigation.prev, navigation.next, data.elements, i);\n        }\n    }));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    data.navigation.prev.remove();\n    data.navigation.next.remove();\n    data.navigation.mutations.stop();\n    data.navigation.actives.stop();\n    data.navigation.clicks.stop();\n    data.navigation = undefined;\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.navigation;\n}\n", "\nimport create from '../../dom/modules/create.js';\n\nexport function enableControls(data) {\n    if (!data.controls) {\n        const nav = create('nav', { part: 'controls' });\n        data.shadow.append(nav);\n        data.controls = nav;\n    }\n}\n\nexport function disableControls(data) {\n    console.log('CONTROLS DISABLE');\n}\n", "\nimport create   from '../../dom/modules/create.js';\nimport delegate from '../../dom/modules/delegate.js';\n\nimport { $data }          from './consts.js';\nimport { enableControls } from './controls.js';\n\n\nfunction update(pagination, children, target) {\n    const { active, buttons, index } = pagination;\n\n    // Do nothing where target is already the active page-button\n    if (active === target) { return; }\n\n    if (index > -1) {\n        pagination.activeSpan.remove();\n        buttons.children[index].part.remove('page-button-active');\n    }\n\n    const i = children.indexOf(target);\n    if (i === -1) { return; }\n\n    buttons.children[i].part.add('page-button-active');\n    buttons.children[i].append(pagination.activeSpan);\n    pagination.index  = i;\n    pagination.active = target;\n}\n\nfunction render(controls, pagination, shadow, children) {\n    if (pagination.buttons) {\n        pagination.buttons.remove();\n        pagination.buttons = undefined;\n    }\n\n    // Don't generate pagination when there are 0 or 1 slides\n    if (children.length < 2) { return; }\n\n    pagination.buttons = create('div', {\n        part: 'pagination',\n        children: children.map((slide, i) => create('button', {\n            part: 'page-button',\n            type: 'button',\n            name: 'pagination',\n            value: i\n        }))\n    });\n\n    controls.append(pagination.buttons);\n}\n\nexport function enable(host) {\n    const data = host[$data];\n    const { shadow, actives, clicks, mutations } = data;\n\n    // Set up nav::part(controls) element\n    enableControls(data);\n\n    // Add an object to store autoplay state\n    const pagination = data.pagination = {\n        // Element containing accessibility text marking a button as active\n        activeSpan: create('span', { class: 'invisible', text: '(Current slide)' })\n    };\n\n    // Render buttons when children change\n    pagination.mutations = mutations.each(() =>\n        render(data.controls, pagination, shadow, data.children.filter((slide) => !slide.dataset.slideIndex))\n    );\n\n    // Create a new stream of actives starting with the current active\n    pagination.actives = actives.each(() =>\n        update(pagination, data.children.filter((slide) => !slide.dataset.slideIndex), data.active)\n    );\n\n    pagination.clicks = clicks.each(delegate({\n        '[name=\"pagination\"]': function(button, e) {\n            const { host } = data;\n            const children = data.children.filter((slide) => !slide.dataset.slideIndex);\n            const target = children[button.value];\n\n            if (!target) { return; }\n            host.active = target;\n\n            // Preemptively highlight pagination button\n            update(pagination, children, target);\n        }\n    }));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    data.pagination.buttons.remove();\n    data.pagination.mutations.stop();\n    data.pagination.actives.stop();\n    data.pagination.clicks.stop();\n    data.pagination = undefined;\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.pagination;\n}\n", "\nimport create   from '../../dom/modules/create.js';\nimport delegate from '../../dom/modules/delegate.js';\nimport { fullscreenEnabled, getFullscreenElement, enterFullscreen, exitFullscreen } from '../../dom/modules/fullscreen.js';\n\nimport { $data }          from './consts.js';\nimport { enableControls } from './controls.js';\n\nexport function enable(host) {\n    const data = host[$data];\n\n    if (!fullscreenEnabled) {\n        if (window.DEBUG) {\n            console.warn('Fullscreen mode not available in this browser');\n        }\n\n        return;\n    }\n\n    // Set up nav::part(controls) element\n    enableControls(data);\n\n    // Add an object to store navigation state\n    const fullscreen = data.fullscreen = {\n        button: create('button', {\n            part: 'fullscreen-button',\n            type: \"button\",\n            name: \"fullscreen\",\n            html: 'Open in fullscreen'\n        }),\n    };\n\n    data.controls.append(fullscreen.button);\n\n    fullscreen.clicks = data.clicks.each(delegate({\n        '[name=\"fullscreen\"]': (button, e) => {\n            const fullscreenCurrent = getFullscreenElement();\n\n            // Make button act as toggle: close the fullscreen\n            if (fullscreenCurrent === host) {\n                exitFullscreen();\n                fullscreen.button.part.remove('fullscreen-button-active');\n                fullscreen.button.innerHTML = 'Open in fullscreen';\n                return;\n            }\n\n            if (fullscreenCurrent) {\n                exitFullscreen();\n            }\n\n            enterFullscreen(host);\n            fullscreen.button.part.add('fullscreen-button-active');\n            fullscreen.button.innerHTML = 'Close fullscreen';\n        }\n    }));\n}\n\nexport function disable(host) {\n    const data = host[$data];\n    const fullscreenCurrent = getFullscreenElement();\n\n    if (fullscreenCurrent === host) {\n        exitFullscreen();\n    }\n\n    data.fullscreen.button.remove();\n    data.fullscreen.clicks.stop();\n    data.fullscreen = undefined;\n}\n\nexport function getState(host) {\n    const data = host[$data];\n    return !!data.fullscreen;\n}\n", "\n// Not true in iPhone iOS.\nexport const fullscreenEnabled = document.fullscreenEnabled\n    || document.mozFullscreenEnabled\n    || document.webkitFullscreenEnabled\n    || document.msFullscreenEnabled ;\n\nexport function getFullscreenElement() {\n    return document.fullscreenElement\n        || document.webkitFullscreenElement\n        || document.mozFullScreenElement\n        || document.msFullscreenElement ;\n}\n\nexport function enterFullscreen(node) {\n    return node.requestFullscreen ? node.requestFullscreen() :\n        node.webkitRequestFullscreen ? node.webkitRequestFullscreen() :\n        node.mozRequestFullScreen ? node.mozRequestFullScreen() :\n        node.msRequestFullscreen ? node.msRequestFullscreen() :\n        undefined ;\n}\n\nexport function exitFullscreen() {\n    document.exitFullscreen ? document.exitFullscreen() :\n    document.webkitExitFullscreen ? document.webkitExitFullscreen() :\n    document.mozCancelFullScreen ? document.mozCancelFullScreen() :\n    document.msExitFullscreen ? document.msExitFullscreen() :\n    undefined ;\n}\n", "\n// Polyfill Element.scrollTo() for Safari\nimport '../dom/polyfills/element.scrollto.js';\n\n/** Get started\n\nDownload the latest release.\n\nThen include the JS and CSS files in your HTML:\n\n```html\n<link rel=\"stylesheet\" href=\"./build/element.css\" />\n<script type=\"module\" src=\"./build/element.js\"></script>\n```\n\nYou can now use the `<slide-show>` in your HTML. The `<slide-show>` example\nabove looks something like this:\n\n```html\n<slide-show autoplay loop controls=\"navigation pagination fullscreen\">\n   <img src=\"./images/donkeys.jpg\" draggable=\"false\" />\n   <img src=\"./images/tractor.jpg\" draggable=\"false\" />\n   <img src=\"./images/mauverin.jpg\" draggable=\"false\" />\n</slide-show>\n```\n\nA `<slide-show>` element lays out its children as slides, by default in\n`grid` mode, although other horizontal modes (`flex`, `inline-block`) are\nsupported. `<slide-show>`s are not only for images – they take any arbitrary\nHTML.\n**/\n\nimport equals          from '../fn/modules/equals.js';\nimport noop            from '../fn/modules/noop.js';\nimport nothing         from '../fn/modules/nothing.js';\nimport Stream          from '../fn/modules/stream.js';\nimport create          from '../dom/modules/create.js';\nimport delegate        from '../dom/modules/delegate.js';\nimport element         from '../dom/modules/element.js';\nimport createBoolean   from '../dom/modules/element/create-boolean.js';\nimport createTokenList from '../dom/modules/element/create-token-list.js';\nimport events, { isPrimaryButton } from '../dom/modules/events.js';\nimport gestures        from '../dom/modules/gestures.js';\nimport { px }          from '../dom/modules/parse-length.js';\nimport rect            from '../dom/modules/rect.js';\nimport Scrolls         from '../dom/modules/scrolls.js';\n\nimport { $data }       from './modules/consts.js';\nimport { scrollTo, jumpTo, updateActive } from './modules/active.js';\nimport { processPointers } from './modules/swipes.js';\n\nimport * as autoplay   from './modules/autoplay.js';\nimport * as loop       from './modules/loop.js';\nimport * as navigation from './modules/navigation.js';\nimport * as pagination from './modules/pagination.js';\nimport * as fullscreen from './modules/fullscreen.js';\n\n\nfunction getWidth(scroller, slides, children) {\n    let n = children.length;\n    let r = -Infinity;\n\n    while (n--) {\n        const box   = rect(children[n]);\n        const right = box.x + box.width;\n        r = right > r ? right : r;\n    }\n\n    const box   = rect(slides);\n    const style = getComputedStyle(scroller);\n    const pl    = px(style.paddingLeft);\n    const pr    = px(style.paddingRight);\n\n    return pl + pr + r - box.x;\n}\n\nfunction updateWidth(scroller, slides, children) {\n    const width = getWidth(scroller, slides, children);\n    scroller.style.setProperty('--scroll-width', width + 'px');\n}\n\nfunction isSlide(slide) {\n    // Filter out loop ghosts\n    return !slide.dataset.slideIndex;\n}\n\n\n/* Element */\n\nconst lifecycle = {\n    // Get path to dir of this module\n    stylesheet:\n        // Support the old path system baked into the Nendaz project\n        window.customElementStylesheetPath && window.customElementStylesheetPath + 'slide-show.shadow.css' ||\n        window.elementSlideShowStylesheet ||\n        import.meta.url.replace(/\\/[^\\/]*([?#].*)?$/, '/') + 'shadow.css',\n\n    construct: function(shadow) {\n        // Shadow DOM\n        const slides   = create('slot', { part: 'slides' });\n        const scroller = create('div',  { class: 'scroller', children: [slides] });\n        const ui       = create('slot', { part: 'ui', name: 'ui' });\n\n        // Add slots to shadow\n        shadow.append(scroller, ui);\n\n        const slotchanges  = events('slotchange', slides).broadcast();\n        const mutations    = Stream.broadcast({ memory: true });\n        const clicks       = events('click', shadow).filter(isPrimaryButton).broadcast();\n        const focuses      = events('focusin', this);\n        const resizes      = events('resize', window);\n        const fullscreens  = events('fullscreenchange', window);\n        const scrolls      = Scrolls(scroller);\n        const swipes       = gestures({ threshold: '0.25rem', device: 'mouse' }, shadow).filter(() => data.children.length > 1);\n        const actives      = Stream.broadcast({ memory: true });\n\n        // Private data\n        const data = this[$data] = {\n            clickSuppressTime: -Infinity,\n            host:     this,\n            style:    window.getComputedStyle(this),\n            elements: nothing,\n            children: nothing,\n            shadow,\n            scroller,\n            slides,\n            actives,\n            slotchanges,\n            mutations,\n            clicks\n        };\n\n        slotchanges.each(() => {\n            const elements = slides.assignedElements();\n            data.elements = elements;\n            updateWidth(data.scroller, data.slides, data.elements);\n\n            const children = data.elements.filter(isSlide);\n            if (!equals(data.children, children)) {\n                data.children = children;\n                mutations.push(children);\n            }\n        });\n\n        resizes.each(() =>\n            updateWidth(data.scroller, data.slides, data.elements)\n        );\n\n        // Prevent default on immediate clicks after a gesture, and don't let\n        // them out: this is a gesture not a click\n        clicks.each(function(e) {\n            const time = window.performance.now();\n            if (time - data.clickSuppressTime < 120) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        });\n\n        // Enable single finger scroll on mouse devices. Bad idea in my opinion,\n        // but designers tend to want it.\n        swipes.each((pointers) => {\n            // Keep a reference to pointers, it's used inside processPointers\n            data.pointers = pointers;\n            pointers.reduce(processPointers, data);\n        });\n\n        fullscreens.each((e) => {\n            // If this slide-show was involved in the fullscreen change\n            // reposition the active slide, it may have been shuftied.\n            if (e.target === this || e.target.contains(this)) {\n                jumpTo(scroller, data.active);\n            }\n        });\n\n        scrolls.each((stream) =>\n            stream\n            .each(noop)\n            .done(() => updateActive(data))\n        );\n\n        // Chrome behaves nicely when shifting focus between slides, Safari and\n        // FF not so much. Let's give them a helping hand at displaying the\n        // focused slide. Todo: FF not getting this.\n        focuses.map((e) =>\n            // Is e.target a slide\n            data.children.indexOf(e.target) !== -1 ? e.target :\n            // Or inside a slide\n            data.children.find((child) => child.contains(e.target))\n        )\n        .each((target) => scrollTo(data.scroller, target));\n    },\n\n    load: function (shadow) {\n        const data = this[$data];\n        data.loaded = true;\n\n        if (this.loop) {\n            loop.enable(this);\n        }\n        else {\n            loop.disable(this);\n        }\n\n        // Update width hack now we have some style loaded\n        updateWidth(data.scroller, data.slides, data.elements);\n\n        // Update and bind to slotchanges on load so that initial `slide-active`\n        // event is guaranteed to be sent after initialisation. (In Chrome and\n        // FF initial `slotchange` event is always sent before load, but not so\n        // in Safari where either order may happen.)\n        updateActive(data);\n        data.slotchanges.each(() => updateActive(data));\n    }\n};\n\nconst properties = {\n    /**\n    .active\n    Gets or sets the currently scroll-snapped child element.\n\n    ```js\n    const activeSlide = slideshow.active;\n    ```\n\n    May be set to one of the child elements, or to the id of one of the\n    child elements, which causes the `slide-show` to scroll.\n\n    ```js\n    slideshow.active = 'slide-1';\n    ```\n    **/\n\n    active: {\n\n\n        set: function(target) {\n            const data = this[$data];\n\n            // Accept an id\n            const child = typeof target !== 'object' ?\n                this.querySelector('#' + (/^\\d/.test((id + '')[0]) ?\n                    '\\\\3' + (id + '')[0] + ' ' + (id + '').slice(1) :\n                    target)\n                ) : target ;\n\n            if (!child) {\n                throw new Error('Cannot set active – not a child of slide-show');\n            }\n\n            scrollTo(data.scroller, child);\n        },\n\n        get: function() {\n            return this[$data].active;\n        }\n    },\n\n    /**\n    autoplay=\"\"\n    Boolean attribute. When present the `slide-show` activates the next\n    slide after a pause. The pause duration may be set with the CSS variable\n    `--slide-duration`. Autoplay is also paused when a mouse pointer is\n    inside the `slide-show`, or when a slide has focus.\n    **/\n\n    /**\n    .autoplay\n\n    Boolean property. When `true` the slide-show activates the next\n    slide after a pause. The pause duration may be set with the CSS variable\n    `--slide-duration`. Autoplay is also paused when a mouse pointer is\n    inside the `slide-show`, or when a slide has focus.\n\n    ```js\n    document.querySelector('slide-show').autoplay = true;\n    ```\n    **/\n\n    autoplay: createBoolean(autoplay),\n\n    /**\n    controls=\"\"\n    An attribute that accepts the tokens `\"navigation\"`, `\"pagination\"`\n    and `\"fullscreen\"`. The presence of one of these tokens enables the\n    corresponding controls.\n    **/\n\n    /**\n    .controls\n    A TokenList object (like `.classList`) that supports the tokens `\"navigation\"`,\n    `\"pagination\"` and `\"fullscreen\"`.\n\n    ```js\n    document.querySelector('slide-show').controls.add('pagination');\n    ```\n    **/\n\n    controls: createTokenList({\n        'navigation': navigation,\n        'pagination': pagination,\n        'fullscreen': fullscreen\n    }),\n\n    /**\n    loop=\"\"\n    Boolean attribute. When present, the `slide-show` behaves as a continuous\n    loop. Looping works by duplicating some of the children of the `slide-show`.\n    Duplicate content is given `aria-hidden=\"true\"` and `tab-index=\"-1\"`, and\n    has `id` attributes stripped off in an attempt to make it inert.\n    **/\n\n    /**\n    .loop\n    Boolean property. When `true`, the `slide-show` behaves as a continuous loop.\n    Looping works by duplicating some of the children of the `slide-show`.\n    Duplicate content is given `aria-hidden=\"true\"` and `tab-index=\"-1\"`, and\n    has `id` attributes stripped off in an attempt to make it inert.\n\n    ```js\n    document.querySelector('slide-show').loop = true;\n    ```\n    **/\n\n    loop: createBoolean(loop)\n};\n\nexport default element('slide-show', lifecycle, properties);\n"],
  "mappings": "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",
  "names": []
}
