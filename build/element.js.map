{
  "version": 3,
  "sources": ["../../fn/modules/cache.js", "../../fn/modules/curry.js", "../../fn/modules/maths/exponential-out.js", "../../fn/modules/noop.js", "../../fn/modules/apply.js", "../../fn/modules/id.js", "../../fn/modules/pipe.js", "../../fn/modules/denormalise.js", "../../dom/modules/transition.js", "../../dom/modules/animate.js", "../../dom/modules/rect.js", "../../dom/polyfills/element.scrollto.js", "../../fn/modules/equals.js", "../../fn/modules/nothing.js", "../../fn/modules/stream/stopable.js", "../../fn/modules/is-iterable.js", "../../fn/modules/stream/stream.js", "../../fn/modules/stream/distributor.js", "../../fn/modules/stream/combine.js", "../../fn/modules/stream/merge.js", "../../fn/modules/stream.js", "../../fn/modules/overload.js", "../../dom/modules/assign.js", "../../dom/modules/create.js", "../../dom/modules/delegate.js", "../../fn/modules/exec.js", "../../fn/modules/capture.js", "../../dom/modules/log.js", "../../dom/modules/element.js", "../../dom/modules/events.js", "../../fn/modules/get.js", "../../fn/modules/to-type.js", "../../fn/modules/parse-value.js", "../../dom/modules/style.js", "../../dom/modules/parse-length.js", "../../dom/modules/gestures.js", "../../dom/modules/scrolls.js", "../../dom/modules/event.js", "../../dom/modules/trigger.js", "../modules/active.js", "../modules/swipe.js", "../modules/autoplay.js", "../modules/loop.js", "../modules/controls.js", "../modules/navigation.js", "../modules/pagination.js", "../../dom/modules/fullscreen.js", "../modules/fullscreen.js", "../element.js"],
  "sourcesContent": ["/**\ncache(fn)\nReturns a function that caches the output values of `fn(input)`\nagainst input values in a map, such that for each input value\n`fn` is only ever called once.\n*/\n\nlet warned;\n\nexport default function cache(fn) {\n    var map = new Map();\n\n    return function cache(object) {\n        if (window.DEBUG && !warned && object === undefined) {\n            warned = true;\n            console.warn('cache() called with undefined. Not illegal, but worthy of a warning.');\n        }\n\n        if (window.DEBUG && arguments.length > 1) {\n            console.warn('cache() called with ' + arguments.length + ' arguments. Accepts exactly 1.');\n        }\n\n        if (map.has(object)) {\n            return map.get(object);\n        }\n\n        var value = fn(object);\n        map.set(object, value);\n        return value;\n    };\n}\n", "/**\ncurry(fn [, muteable, arity])\nReturns a function that wraps `fn` and makes it partially applicable.\n*/\n\nimport cache from './cache.js';\n\nconst A     = Array.prototype;\n\nfunction applyFn(fn, args) {\n    return typeof fn === 'function' ? fn.apply(null, args) : fn ;\n}\n\nfunction curry(fn, muteable, arity) {\n    arity = arity || fn.length;\n\n    var memo = arity === 1 ?\n        // Don't cache if `muteable` flag is true\n        muteable ? fn : cache(fn) :\n\n        // It's ok to always cache intermediate memos, though\n        cache(function(object) {\n            return curry(function() {\n                var args = [object];\n                args.push.apply(args, arguments);\n                return fn.apply(null, args);\n            }, muteable, arity - 1) ;\n        }) ;\n\n    return function partial(object) {\n        return arguments.length === 0 ?\n            partial :\n        arguments.length === 1 ?\n            memo(object) :\n        arguments.length >= arity ?\n            fn.apply(null, arguments) :\n        // This is bad, I think. We don't want [[fn],[fn]].map(get(0)) to be firing the fns\n        //arguments.length > arity ?\n        //    applyFn(fn.apply(null, A.splice.call(arguments, 0, arity)), arguments) :\n        applyFn(memo(object), A.slice.call(arguments, 1)) ;\n    };\n}\n\n//function curry(fn, muteable, arity) {\n//    arity = arity || fn.length;\n//    return function curried() {\n//        return arguments.length >= arity ?\n//            fn.apply(null, arguments) :\n//            curried.bind(null, ...arguments) ;\n//    };\n//}\n\nif (window.DEBUG) {\n    const _curry = curry;\n\n    // Feature test\n\tconst isFunctionLengthDefineable = (function() {\n\t\tvar fn = function() {};\n\n\t\ttry {\n\t\t\t// Can't do this on Safari - length non configurable :(\n\t\t\tObject.defineProperty(fn, 'length', { value: 2 });\n\t\t}\n\t\tcatch(e) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn fn.length === 2;\n\t})();\n\n    const setFunctionProperties = function setFunctionProperties(text, parity, fn1, fn2) {\n        // Make the string representation of fn2 display parameters of fn1\n        fn2.toString = function() {\n            return /function\\s*[\\w\\d]*\\s*\\([,\\w\\d\\s]*\\)/.exec(fn1.toString()) + ' { [' + text + '] }';\n        };\n\n        // Where possible, define length so that curried functions show how\n        // many arguments they are yet expecting\n        if (isFunctionLengthDefineable) {\n            Object.defineProperty(fn2, 'length', { value: parity });\n        }\n\n        return fn2;\n    };\n\n    // Make curried functions log a pretty version of their partials\n    curry = function curry(fn, muteable, arity) {\n        arity  = arity || fn.length;\n        return setFunctionProperties('curried', arity, fn, _curry(fn, muteable, arity));\n    };\n}\n\n\nexport default curry;\n", "// Exponential functions\n//\n// e - exponent\n// x - range 0-1\n//\n// eg.\n// var easeInQuad   = exponential(2);\n// var easeOutCubic = exponentialOut(3);\n// var easeOutQuart = exponentialOut(4);\n\nimport curry from '../curry.js';\n\nexport function exponentialOut(e, x) {\n    return 1 - Math.pow(1 - x, e);\n}\n\nexport default curry(exponentialOut);\n", "/**\nnoop()\nReturns undefined.\n*/\n\nexport default function noop() {}\n", "export default function apply(value, fn) {\n    return fn(value);\n}\n", "/**\nid(value)\nReturns `value`.\n*/\n\nexport default function id(value) { return value; }\n", "/**\npipe(fn1, fn2, ...)\nReturns a function that calls `fn1`, `fn2`, etc., passing the result of\ncalling one function to the next and returning the the last result.\n*/\n\nimport apply from './apply.js';\nimport id from './id.js';\n\nconst A = Array.prototype;\n\nexport default function pipe() {\n    const fns = arguments;\n    return fns.length ?\n        (value) => A.reduce.call(fns, apply, value) :\n        id ;\n}\n", "\nexport default function linear(min, max, value) {\n    return value * (max - min) + min;\n}\n", "\n\n/**\ntransition(duration, fn)\n\nCalls `fn` on each animation frame until `duration` seconds has elapsed. `fn`\nis passed a single argument `progress`, a number that ramps from `0` to `1` over\nthe duration of the transition. Returns a function that cancels the transition.\n\n```\ntransition(3, function(progress) {\n    // Called every frame for 3 seconds\n});\n```\n*/\n\nconst performance           = window.performance;\nconst requestAnimationFrame = window.requestAnimationFrame;\nconst cancelAnimationFrame  = window.cancelAnimationFrame;\n\nexport default function transition(duration, fn, end) {\n\tvar t0 = performance.now();\n\n\tfunction frame(t1) {\n\t\t// Progress from 0-1\n\t\tvar progress = (t1 - t0) / (duration * 1000);\n\n\t\tif (progress < 1) {\n\t\t\tif (progress > 0) {\n\t\t\t\tfn(progress);\n\t\t\t}\n\t\t\tid = requestAnimationFrame(frame);\n\t\t}\n\t\telse {\n\t\t\tfn(1);\n\t\t\tend && end();\n\t\t}\n\t}\n\n\tvar id = requestAnimationFrame(frame);\n\n\treturn function cancel() {\n\t\tcancelAnimationFrame(id);\n\t};\n}\n", "\n\n/**\nanimate(duration, transform, name, object, value)\n\nAnimates property `name` of `object` to `value` over `duration` seconds, using\nthe `transform` function as an easing function, and updates the object on\nanimation frames.\n\n```\nduration  - number in seconds\ntransform - function that maps x (0-1) to y (0-1)\nname      - string name of property to animate\nobject    - object to animate\nvalue     - target value\nfn        - optional function to call on completion\n```\n*/\n\nimport pipe        from '../../fn/modules/pipe.js';\nimport denormalise from '../../fn/modules/denormalise.js';\nimport transition  from './transition.js';\n\nexport default function animate(duration, transform, name, object, stopValue, fn) {\n\t// denormaliseLinear is not curried! Wrap it.\n    const startValue = object[name];\n\treturn transition(\n\t\tduration,\n\t\tpipe(transform, (progress) => denormalise(startValue, stopValue, progress), (value) => (object[name] = value)),\n\t\tfn\n\t);\n}\n", "\n/**\nrect(node)\n\nReturns a `DOMRect` object describing the draw rectangle of `node`.\n(If `node` is `window` a preudo-DOMRect object is returned).\n**/\n\nfunction windowBox() {\n\treturn {\n\t\tx:      0,\n\t\ty:      0,\n\t\tleft:   0,\n\t\ttop:    0,\n\t\tright:  window.innerWidth,\n\t\tbottom: window.innerHeight,\n\t\twidth:  window.innerWidth,\n\t\theight: window.innerHeight\n\t};\n}\n\nexport default function rect(node) {\n\treturn node === window ?\n\t\twindowBox() :\n        // In Safari SVG shapes dont get a .getClientRects()[0] so fallback to\n        // .getBoundingClientRect()\n\t\tnode.getClientRects()[0] || node.getBoundingClientRect() ;\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { rect });\n}\n", "/**\nelement.scrollTo()\n\nMonkey patches `Element.scrollTo()` to support smooth scrolling options.\nhttps://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTo\n**/\n\nimport expOut   from '../../fn/modules/maths/exponential-out.js';\nimport noop     from '../../fn/modules/noop.js';\nimport animate  from '../modules/animate.js';\nimport rect     from '../modules/rect.js';\n\n// Duration and easing of scroll animation\nconst config = {\n    scrollDuration: 0.3,\n    scrollDurationPerHeight: 0.125,\n    scrollTransform: expOut(3)\n};\n\nlet cancel = noop;\n\nfunction scrollToPosition(scrollParent, options) {\n    if (options.behavior === 'smooth') {\n        // Switch off scroll snap\n        const scrollSnapType = scrollParent.style.getPropertyValue('scroll-snap-type');\n        const undoScrollSnap = () => (scrollParent.style.setProperty('scroll-snap-type', scrollSnapType));\n        scrollParent.style.setProperty('scroll-snap-type', 'none');\n\n        if (options.left !== undefined) {\n            const scrollBoxWidth = scrollParent === document.body ?\n                // We cannot guarantee that body width is 100%. Use the window\n                // innerHeight instead.\n                window.innerWidth :\n                rect(scrollParent).width ;\n\n            const scrollDuration = config.scrollDuration\n                + config.scrollDurationPerHeight\n                * Math.abs(options.left - scrollParent.scrollLeft)\n                / scrollBoxWidth ;\n\n            // duration, transform, name, object, value, endFn\n            cancel = animate(scrollDuration, config.scrollTransform, 'scrollLeft', scrollParent, options.left, undoScrollSnap);\n        }\n        else {\n            const scrollBoxHeight = scrollParent === document.body ?\n                // We cannot guarantee that body height is 100%. Use the window\n                // innerHeight instead.\n                window.innerHeight :\n                rect(scrollParent).height ;\n\n            const scrollDuration = config.scrollDuration\n                + config.scrollDurationPerHeight\n                * Math.abs(options.top - scrollParent.scrollTop)\n                / scrollBoxHeight ;\n\n            cancel = animate(scrollDuration, config.scrollTransform, 'scrollTop', scrollParent, options.top, undoScrollSnap);\n        }\n    }\n    else {\n        options.left !== undefined && (scrollParent.scrollLeft = options.left) ;\n        options.top  !== undefined && (scrollParent.scrollTop  = options.top) ;\n    }\n}\n\nif (!('scrollBehavior' in document.documentElement.style)) {\n    console.log('Polyfilling Element.scrollTo(options).');\n\n    // Get the method from HTMLElement - in some browsers it is here rather\n    // than on Element\n    const constructor = 'scrollTo' in Element.prototype ? Element : HTMLElement ;\n    const scrollTo    = constructor.scrollIntoView;\n\n    constructor.prototype.scrollTo = function(options) {\n        if (typeof options === 'object') {\n            scrollToPosition(this, options);\n        }\n        else {\n            scrollTo.apply(this, arguments);\n        }\n    };\n}\n", "\n/**\nequals(a, b)\nPerform a deep equality comparison of `a` and `b`. Returns `true` if\nthey are equal.\n*/\n\nimport curry from './curry.js';\n\nexport function equals(a, b) {\n    // Fast out if references are for the same object\n    if (a === b) { return true; }\n\n    // If either of the values is null, or not an object, we already know\n    // they're not equal so get out of here\n    if (a === null ||\n        b === null ||\n        typeof a !== 'object' ||\n        typeof b !== 'object') {\n        return false;\n    }\n\n    // Compare their enumerable keys\n    const akeys = Object.keys(a);\n    const bkeys = Object.keys(b);\n\n    let n = akeys.length;\n    while (n--) {\n        // Has the property been set to undefined on a?\n        if (a[akeys[n]] === undefined) {\n            // We don't want to test if it is an own property of b, as\n            // undefined represents an absence of value\n            if (b[akeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // console.log(equals(a[akeys[n]], b[akeys[n]]), akeys[n], a[akeys[n]], b[akeys[n]]);\n            if (!b.hasOwnProperty(akeys[n]) || !equals(a[akeys[n]], b[akeys[n]])) {\n                return false;\n            }\n        }\n\n        const i = bkeys.indexOf(akeys[n]);\n        if (i > -1) {\n            bkeys.splice(i, 1);\n        }\n    }\n\n    n = bkeys.length;\n    while (n--) {\n        // Has the property been set to undefined on b?\n        if (b[bkeys[n]] === undefined) {\n            if (a[bkeys[n]] !== undefined) {\n                return false;\n            }\n        }\n        else {\n            // We already know a does not have own property bkeys[n], because\n            // we have already been through all the enumerable properties\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport default curry(equals, true);\n", "import noop from './noop.js';\n\nconst define = Object.defineProperties;\nconst freeze = Object.freeze;\n\nfunction self() {\n    return this;\n}\n\nexport default freeze(define([], {\n    // Make array and stream methods no-ops\n    shift:   { value: noop },\n    push:    { value: noop },\n    each:    { value: noop },\n    forEach: { value: noop },\n    start:   { value: noop },\n    stop:    { value: noop },\n    done:    { value: noop },\n    join:    { value: function() { return ''; } },\n    map:     { value: self },\n    filter:  { value: self },\n    reduce:  { value: function(fn, accumulator) { return accumulator; } }\n}));\n", "\nconst assign = Object.assign;\n\nfunction stopOne(stopable) {\n    return stopable.stop ?\n        stopable.stop() :\n        stopable() ;\n}\n\nfunction stopAll(stopables) {\n    stopables.forEach(stopOne);\n    stopables.length = 0;\n}\n\n\n/**\nStopable()\n**/\n\nexport default function Stopable() {}\n\nassign(Stopable.prototype, {\n    stop: function stop() {\n        this.stopables && stopAll(this.stopables);\n    },\n\n    done: function done(fn) {\n        const stopables = this.stopables || (this.stopables = []);\n        stopables.push(fn);\n    }\n});\n", "\n/**\nisIterable(value)\n**/\n\nexport default function isIterable(object) {\n    return object && object[Symbol.iterator];\n}\n", "\nimport id         from '../id.js';\nimport isIterable from '../is-iterable.js';\nimport noop       from '../noop.js';\n\nimport Stopable   from './stopable.js';\n\nconst assign = Object.assign;\nconst create = Object.create;\nconst define = Object.defineProperties;\n\n\n/* Source */\n\nfunction startError() {\n    throw new Error('Attempted stream.start() but stream already started');\n}\n\nfunction pushError() {\n    throw new Error('Attempted stream.push() to a stopped stream');\n}\n\nexport function Source(start) {\n    this.setup = start;\n}\n\nassign(Source.prototype, Stopable.prototype, {\n    pipe: function(stream) {\n        this.target = stream;\n    },\n\n    start: function() {\n        // Method may be used once only\n        if (window.DEBUG) { this.start = startError; }\n        const setup = this.setup;\n        setup(this.target, arguments);\n    }\n});\n\nif (window.DEBUG) {\n    // Override Source.stop() with error handling for push() after stop()\n    Source.prototype.stop = function() {\n        // Cannot push() after stop()\n        this.push = pushError;\n        Stopable.prototype.stop.apply(this, arguments);\n    };\n}\n\n\n/**\nStream(fn)\nCreates a mappable stream of values.\n**/\n\nexport default function Stream(start) {\n    // Support construction without `new`\n    if (!Stream.prototype.isPrototypeOf(this)) {\n        return new Stream(start);\n    }\n\n    this.source = typeof start === 'function' ?\n        // New source calls start(source) when the stream is started\n        new Source(start) :\n        // Also accept a producer stream as source. It will be started, stopped\n        // and done when this stream is started, stopped and done.\n        start ;\n\n    this.source.pipe(this);\n}\n\n\nassign(Stream, {\n    /**\n    Stream.from(values)\n    Creates a stream from the array (or array-like) collection `values`.\n    **/\n    from: function(values) {\n        return new Stream(values.length ?\n            (controller) => controller.push.apply(controller, values) :\n            noop\n        );\n    },\n\n    /**\n    Stream.of(value1, value2, ...)\n    Creates a stream using parameters as values.\n    **/\n    of: function() {\n        return this.from(arguments);\n    }\n});\n\nassign(Stream.prototype, {\n    /**\n    .push(value)\n    Pushes `value` into the stream. If the stream has not been started or is\n    already stopped this will cause an error.\n    **/\n    push: function() {\n        const target = this.target;\n\n        // If there is no target the stream has not been started yet\n        if (window.DEBUG && !target) {\n            throw new Error('Cannot .push() to unstarted stream');\n        }\n\n        const length = arguments.length;\n        let n = -1;\n        while (++n < length) {\n            arguments[n] !== undefined && target.push(arguments[n]);\n        }\n\n        return this;\n    },\n\n    /**\n    .pipe(stream)\n    Starts the stream and pushes its values to `stream`.\n    Returns `stream`.\n    **/\n    pipe: function(target) {\n        this.target = target;\n        this.start();\n        return target;\n    },\n\n    /**\n    .start()\n    Starts the stream. Normally this is called internally by a consumer method.\n    Caution: where `start()` is called and values are pushed to the stream\n    without a consumer attached, the stream will error.\n    **/\n    start: function() {\n        this.source.start.apply(this.source, arguments);\n        return this;\n    },\n\n    /**\n    .stop()\n    Stops the stream.\n    **/\n    stop: function() {\n        this.source.stop.apply(this.source, arguments);\n        return this;\n    },\n\n    /**\n    .done(fn)\n    Cues `fn` to be called when the stream is stopped.\n    **/\n    done: function(fn) {\n        this.source.done(fn);\n        return this;\n    }\n});\n\n\n\n/*\nTransforms\n*/\n\nconst properties = {\n    source: { writable: true },\n    target: { writable: true }\n};\n\n/*\nMap()\n*/\n\nconst mapProperties = assign({ fn: { value: id }}, properties);\n\nexport function Map(source, producer, fn) {\n    mapProperties.source.value = source;\n    mapProperties.fn.value = fn;\n    define(this, mapProperties);\n    // producer.pipe(this) ??\n    producer.target = this;\n}\n\nMap.prototype = create(Stream.prototype);\n\nMap.prototype.push = function map(value) {\n    value = this.fn(value);\n\n    if (value !== undefined) {\n        this.target.push(value);\n    }\n\n    return this;\n};\n\n\n/*\nFilter()\n*/\n\nexport function Filter(source, producer, fn) {\n    mapProperties.source.value = source;\n    mapProperties.fn.value = fn;\n    define(this, mapProperties);\n    // producer.pipe(this) ??\n    producer.target = this;\n}\n\nFilter.prototype = create(Stream.prototype);\n\nFilter.prototype.push = function filter(value) {\n    if (this.fn(value)) {\n        this.target.push(value);\n    }\n\n    return this;\n};\n\n\n/*\nFlatMap()\n*/\n\nexport function FlatMap(source, producer, fn) {\n    mapProperties.source.value = source;\n    mapProperties.fn.value = fn;\n    define(this, mapProperties);\n    // producer.pipe(this) ??\n    producer.target = this;\n}\n\nFlatMap.prototype = create(Stream.prototype);\n\nFlatMap.prototype.push = function flatMap(value) {\n    const values = this.fn(value);\n\n    if (values !== undefined) {\n        if (isIterable(values)) {\n            for (const value of values) {\n                if (value !== undefined) {\n                    this.target.push(value);\n                }\n            }\n        }\n        else {\n            // Todo: support flattening of streams. Should streams by made\n            // iterable? CAN streams be made iterable? They'd have to be async.\n            throw new Error('Cannot .flatMap() non-iterable values');\n        }\n    }\n\n    return this;\n};\n\n\n/*\nTake()\n*/\n\nconst takeProperties = assign({ n: { value: 0, writable: true }}, properties);\n\nexport function Take(source, producer, n) {\n    if (typeof n !== 'number' || n < 1) {\n        throw new Error('stream.take(n) accepts non-zero positive integers as n (' + n + ')');\n    }\n\n    takeProperties.source.value = source;\n    takeProperties.n.value = n;\n    define(this, takeProperties);\n    // producer.pipe(this) ??\n    producer.target = this;\n}\n\nTake.prototype = create(Stream.prototype);\n\nTake.prototype.push = function take(value) {\n    this.target.push(value);\n\n    if (!(--this.n)) {\n        this.stop();\n    }\n\n    return this;\n};\n\n\n/*\nReduce()\nTodo: see notes next to .reduce() method\n*/\n\nconst reduceProperties = assign({\n    value: { writable: true }\n}, mapProperties);\n\nexport function Reduce(source, producer, fn, accumulator) {\n    reduceProperties.source.value = source;\n    reduceProperties.fn.value = fn;\n    reduceProperties.value.value = accumulator;\n    define(this, reduceProperties);\n    // producer.pipe(this) ??\n    producer.target = this;\n    source.start();\n}\n\nReduce.prototype = create(Stream.prototype);\n\nReduce.prototype.push = function reduce(value) {\n    value = this.fn(this.value, value);\n\n    if (value !== undefined) {\n        this.value = value;\n    }\n\n    return this;\n};\n\n\n/*\nScan()\n*/\n\nexport function Scan(source, producer, fn, accumulator) {\n    reduceProperties.source.value = source;\n    reduceProperties.fn.value = fn;\n    reduceProperties.value.value = accumulator;\n    define(this, reduceProperties);\n    // producer.pipe(this) ??\n    producer.target = this;\n}\n\nScan.prototype = create(Stream.prototype);\n\nScan.prototype.push = function scan(value) {\n    value = this.fn(this.value, value);\n\n    if (value !== undefined) {\n        this.value = value;\n        this.target.push(value);\n    }\n\n    return this;\n};\n\n\n/*\nEach()\n*/\n\nconst eachProperties = {\n    source: { writable: true }\n};\n\nexport function Each(source, producer, fn) {\n    eachProperties.source.value = source;\n    define(this, eachProperties);\n    this.push = fn;\n    // producer.pipe(this) ??\n    producer.target = this;\n    source.start();\n}\n\nEach.prototype = create(Stream.prototype, {\n    // Can't consume a consumed stream\n    each: { value: null },\n    pipe: { value: null }\n});\n", "\nimport Stopable from './stopable.js';\nimport Stream, { Map, Filter, FlatMap, Reduce, Scan, Take, Each } from './stream.js';\n\nconst create = Object.create;\nconst assign = Object.assign;\n\n/**\nSource\n**/\n\nfunction Source(source) {\n    this.source = source;\n    this.target = undefined;\n}\n\nassign(Source.prototype, Stopable.prototype, {\n    start: function() {\n        const source  = this.source;\n        const targets = source.targets;\n        const target  = this.target;\n\n        // Add this target to distributor targets\n        targets.push(target);\n\n        // Push initial value\n        if (source.value !== undefined) {\n            target.push(this.source.value);\n        }\n\n        if (targets.length === 1) {\n            //this.source.start();\n            this.source.source.pipe(this.source);\n        }\n    },\n\n    stop: function() {\n        const targets = this.source.targets;\n        const target  = this.target;\n\n        // Get index of target\n        const i = targets.indexOf(target);\n\n        // Splice it out\n        targets.splice(i, 1);\n\n        // Stop this stream\n        Stopable.prototype.stop.apply(this, arguments);\n\n        // If there are no targets left stop the distributor\n        if (targets.length === 0) {\n            this.source.stop();\n        }\n    }\n});\n\n\n/**\nDistributor(source, memorise)\nWhere `source` is a source stream and `memorise` is an optional boolean that\ntells the distributor to emit latest value as the initial value of a newly\ncreated forked stream.\n**/\n\nexport default function Distributor(source, memorise) {\n    if (window.DEBUG && !source) {\n        throw new Error('Distributor() requires a source');\n    }\n\n    this.source   = source;\n    this.targets  = [];\n    this.memorise = !!memorise;\n}\n\nDistributor.prototype = assign(create(Stream.prototype), {\n    push: function(value) {\n        const targets = this.targets;\n\n        // If there is no target the stream has not been started yet\n        if (window.DEBUG && !targets.length) {\n            console.warn('Attempt to .push() to idle distributor', value);\n        }\n\n        if (value !== undefined) {\n            let t = -1;\n            while (targets[++t]) {\n                targets[t].push(value);\n            }\n\n            // Memorise value so that newly forked streams may be initialised\n            // with latest value\n            if (this.memorise) {\n                this.value = value;\n            }\n        }\n\n        return this;\n    },\n\n    pipe: function(stream) {\n        console.log('TODO: Distributor.pipe()');\n        return stream;\n    },\n\n    /**\n    .map(fn)\n    Maps each value in the stream to `fn(value)`. Resulting values that are not\n    `undefined` are pushed downstream.\n    **/\n    map: function(fn) {\n        const source = new Source(this);\n        return new Map(source, source, fn);\n    },\n\n    /**\n    .filter(fn)\n    Filters out values from the stream where `fn(value)` is falsy.\n    **/\n    filter: function(fn) {\n        const source = new Source(this);\n        return new Filter(source, source, fn);\n    },\n\n    /**\n    .flatMap(fn)\n    **/\n    flatMap: function(fn) {\n        const source = new Source(this);\n        return new FlatMap(source, source, fn);\n    },\n\n    /**\n    .reduce(fn, initial)\n    Consumes the stream. TODO: Not sure what to return old boy.\n    **/\n    reduce: function(fn, initial) {\n        const source = new Source(this);\n        return new Reduce(source, source, fn, initial);\n    },\n\n    /**\n    .scan(fn, initial)\n    Calls `fn(current, value)` for each `value` in the stream. Where `fn`\n    returns a value it is pushed downstream, and `current` assumes that value\n    on the next iteration. Where `fn` returns `undefined` nothing is pushed and\n    `current` remains unchanged.\n    **/\n    scan: function(fn, accumulator) {\n        const source = new Source(this);\n        return new Scan(source, source, fn, accumulator);\n    },\n\n    /**\n    .take(n)\n    Returns a stream of the first `n` values of the stream.\n    **/\n    take: function(n) {\n        const source = new Source(this);\n        return new Take(source, source, n);\n    },\n\n    /**\n    .each(fn)\n    Starts the stream and calls `fn(value)` for each value in it.\n    Returns the stream.\n    **/\n    each: function(fn) {\n        const source = new Source(this);\n        return new Each(source, source, fn);\n    }\n});\n", "\nimport Stream from './stream.js';\n\nconst assign = Object.assign;\nconst keys = Object.keys;\n\nexport default function Combine(streams) {\n    return new Stream((controller) => {\n        const values = {};\n        const names  = keys(streams);\n\n        let active = false;\n        function push(name, value) {\n            values[name] = value;\n            if (active || (active = keys(values).length === names.length)) {\n                controller.push(assign({}, values));\n            }\n        }\n\n        for (const name in streams) {\n            const stream = streams[name];\n\n            if (stream.each) {\n                stream.each((value) => push(name, value));\n                // Stop stream when controller stops\n                controller.done(stream);\n            }\n            else if (stream.then) {\n                stream.then((value) => push(name, value));\n                // Todo: what do we do with errors?\n            }\n            else {\n                console.log('Todo: combine() raw values ?');\n            }\n        }\n    });\n}\n", "\nimport Stream from './stream.js';\n\n/*\nMerge()\n*/\n\nexport default function Merge(streams) {\n    return new Stream((controller) => {\n        let i = -1, stream;\n        while (stream = streams[++i]) {\n            if (stream.each) {\n                // Merge streams\n                stream.each((value) => controller.push(value));\n                // And stop them when this one stops?\n                controller.done(stream);\n            }\n            else if (stream.then) {\n                stream.then((value) => controller.push(value));\n                // What should we do with errors?\n            }\n            else {\n                // Merge arrays or array-likes\n                controller.push.apply(controller, stream);\n            }\n        }\n    });\n}\n", "\nimport Stream, { Map, Filter, FlatMap, Reduce, Scan, Take, Each } from './stream/stream.js';\nimport Distributor from './stream/distributor.js';\nimport Combine     from './stream/combine.js';\nimport Merge       from './stream/merge.js';\n\nconst assign = Object.assign;\n\nassign(Stream, {\n    /**\n    Stream.combine(streams)\n    Creates a stream by combining the latest values of all input streams into\n    an objects containing those values. A new object is emitted when a new value\n    is pushed to any input stream.\n    **/\n    distribute: function distribute(memorise) {\n        return Stream.of().distribute(memorise);\n    },\n\n    /**\n    Stream.combine(streams)\n    Creates a stream by combining the latest values of all input streams into\n    an objects containing those values. A new object is emitted when a new value\n    is pushed to any input stream.\n    **/\n    combine: function combine(streams) {\n        return Combine(streams);\n    },\n\n    /**\n    Stream.merge(stream1, stream2, ...)\n    Creates a stream by merging values from any number of input streams into a\n    single output stream.\n    **/\n    merge: function() {\n        return Merge(arguments);\n    },\n});\n\nassign(Stream.prototype, {\n    /**\n    .map(fn)\n    Maps each value in the stream to `fn(value)`. Resulting values that are not\n    `undefined` are pushed downstream.\n    **/\n    map: function(fn) {\n        return new Map(this.source, this, fn);\n    },\n\n    /**\n    .filter(fn)\n    Filters out values from the stream where `fn(value)` is falsy.\n    **/\n    filter: function(fn) {\n        return new Filter(this.source, this, fn);\n    },\n\n    /**\n    .flatMap(fn)\n    **/\n    flatMap: function(fn) {\n        return new FlatMap(this.source, this, fn);\n    },\n\n    /**\n    .reduce(fn, initial)\n    Consumes the stream. TODO: Not sure what to return old boy.\n    **/\n    reduce: function(fn, initial) {\n        return new Reduce(this.source, this, fn, initial);\n    },\n\n    /**\n    .scan(fn, initial)\n    Calls `fn(current, value)` for each `value` in the stream. Where `fn`\n    returns a value it is pushed downstream, and `current` assumes that value\n    on the next iteration. Where `fn` returns `undefined` nothing is pushed and\n    `current` remains unchanged.\n    **/\n    scan: function(fn, accumulator) {\n        return new Scan(this.source, this, fn, accumulator);\n    },\n\n    /**\n    .take(n)\n    Returns a stream of the first `n` values of the stream.\n    **/\n    take: function(n) {\n        return new Take(this.source, this, n);\n    },\n\n    /**\n    .each(fn)\n    Starts the stream and calls `fn(value)` for each value in it.\n    Returns the stream.\n    **/\n    each: function(fn) {\n        return new Each(this.source, this, fn);\n    },\n\n    /**\n    .distribute(memorise)\n    **/\n    distribute: function(options) {\n        return new Distributor(this, options && options.memory);\n    }\n});\n\nexport default Stream;\n\n\n// Debug\n\nif (window.DEBUG) {\n    window.Stream = Stream;\n}\n\n", "/**\noverload(fn, map)\n\nReturns a function that calls a function at the property of `object` that\nmatches the result of calling `fn` with all arguments.</p>\n\n```\nvar fn = overload(toType, {\n    string: function a(name, n) {...},\n    number: function b(n, m) {...}\n});\n\nfn('pie', 4); // Returns a('pie', 4)\nfn(1, 2);     // Returns b(1, 2)\n```\n*/\n\n\nexport default function overload(fn, map) {\n    return function overload() {\n        const key     = fn.apply(this, arguments);\n        const handler = (map[key] || map.default);\n\n        if (!handler) {\n            throw new Error('overload() no handler for \"' + key + '\"');\n        }\n\n        return handler.apply(this, arguments);\n    };\n}\n", "/**\nassign(node, properties)\n\nAssigns each property of `properties` to `node`, as a property where that\nproperty exists in `node`, otherwise as an attribute.\n\nIf `properties` has a property `'children'` it must be an array of nodes;\nthey are appended to 'node'.\n\nThe property `'html'` is aliased to `'innerHTML'`. The property `'text'` \nis aliased to `'textContent'`. The property `'tag'` is treated as an alias \nof `'tagName'` (which is ignored, as `node.tagName` is read-only). The \nproperty `'is'` is also ignored.\n*/\n\nimport curry from '../../fn/modules/curry.js';\nimport id from '../../fn/modules/id.js';\nimport noop from '../../fn/modules/noop.js';\nimport overload from '../../fn/modules/overload.js';\n\nconst assignProperty = overload(id, {\n\t// Ignore read-only properties or attributes\n\tis: noop,\n\ttag: noop,\n\n\thtml: function(name, node, content) {\n\t\tnode.innerHTML = content;\n\t},\n\n\ttext: function(name, node, content) {\n\t\tnode.textContent = content;\n\t},\n\n\tchildren: function(name, node, content) {\n\t\t// Empty the node and append children\n\t\tnode.innerHTML = '';\n\t\tcontent.forEach((child) => { node.appendChild(child) });\n\t},\n\n\t// SVG points property must be set as string attribute - SVG elements\n\t// have a read-only API exposed at .points\n\tpoints: setAttribute,\n    cx:     setAttribute,\n    cy:     setAttribute,\n    r:      setAttribute,\n    preserveAspectRatio: setAttribute,\n    viewBox: setAttribute,\n\n\tdefault: function(name, node, content) {\n\t\tif (name in node) {\n\t\t\tnode[name] = content;\n\t\t}\n\t\telse {\n\t\t\tnode.setAttribute(name, content);\n\t\t}\n\t}\n});\n\nfunction setAttribute(name, node, content) {\n\tnode.setAttribute(name, content);\n}\n\nexport function assign(node, attributes) {\n\tvar names = Object.keys(attributes);\n\tvar n = names.length;\n\n\twhile (n--) {\n\t\tassignProperty(names[n], node, attributes[names[n]]);\n\t}\n\n\treturn node;\n}\n\nexport default curry(assign, true);\n", "\nimport id       from '../../fn/modules/id.js';\nimport overload from '../../fn/modules/overload.js';\nimport assign   from './assign.js';\n\nconst svgNamespace = 'http://www.w3.org/2000/svg';\n\nconst div           = document.createElement('div');\nconst typeofTag     = (tag, content)  => (tag && typeof tag);\nconst typeofContent = (type, content) => (content && typeof content);\n\n// Constructors\n\nfunction createContextFragment(context, html) {\n    const range = document.createRange();\n    range.selectNode(context);\n    return range.createContextualFragment(html);\n}\n\nfunction createSVG(tag, html) {\n    var node = document.createElementNS(svgNamespace, tag);\n\n    if (html) {\n        node.innerHTML = html;\n    }\n\n    return node;\n}\n\n/**\ncreate(tag, content)\n\nConstructs and returns a new DOM node.\n\n- If `tag` is `\"text\"` a text node is created.\n- If `tag` is `\"fragment\"` a fragment is created.\n- If `tag` is `\"comment\"` a comment is created.\n- If `tag` is any other string the element `<tag></tag>` is created.\n\nWhere a comment or text node is created `content` must be a string, as is set as\ntextContent. For fragments and other nodes:\n\n- If `content` is a string it is set as innerHTML.\n- If `content` is array-like its items are appended to node. Note that where\n`content` is a NodeList, this removes nodes from whatever the NodeList belongs\nto.\n- If `content` is an object its properties are assigned as node properties or\nattributes.\n\nWhere node is a fragment there is an optional third parameter `context`, which\nmust be an element. The fragment parser is run in the context of the element:\n\n```\ncreate('fragment', '<li>', document.querySelector('ul'));\n```\n**/\n\nconst create = overload(id, {\n    comment: function(tag, text) {\n        return document.createComment(text || '');\n    },\n\n    fragment: overload(typeofContent, {\n        string: function(tag, html, context) {\n            if (context) {\n                return createContextFragment(context, html);\n            }\n\n            const fragment = document.createDocumentFragment();\n            div.innerHTML = html;\n            const nodes = div.childNodes;\n            while (nodes[0]) { fragment.appendChild(nodes[0]); }\n            return fragment;\n        },\n\n        object: function(tag, object, context) {\n            // If there is context, create a context-aware fragment\n            const fragment = context ?\n                createContextFragment(context) :\n                document.createDocumentFragment() ;\n\n            // Is object array-like?\n            if (typeof object.length === 'number') {\n                // Be careful here in case object is a live NodeList, which will\n                // mutate as you iterate over it. Applying object to .append()\n                // appears to not have this problem, and will work on arrays.\n                fragment.append.apply(fragment, object);\n            }\n            else {\n                assign(fragment, object);\n            }\n\n            return fragment;\n        },\n\n        default: () => document.createDocumentFragment()\n    }),\n\n    text: function (tag, text) {\n        return document.createTextNode(text || '');\n    },\n\n    circle:   createSVG,\n    ellipse:  createSVG,\n    g:        createSVG,\n    glyph:    createSVG,\n    image:    createSVG,\n    line:     createSVG,\n    rect:     createSVG,\n    use:      createSVG,\n    path:     createSVG,\n    pattern:  createSVG,\n    polygon:  createSVG,\n    polyline: createSVG,\n    svg:      createSVG,\n\n    default: overload(typeofContent, {\n        string: function(tag, html) {\n            const node = document.createElement(tag);\n            node.innerHTML = html;\n            return node;\n        },\n\n        object: function(tag, object) {\n            const node = document.createElement(tag);\n\n            // Is it array-like?\n            if (typeof object.length === 'number') {\n                // Be careful here in case object is a live NodeList, which will\n                // mutate as you iterate over it. Applying object to .append()\n                // appears to not have this problem, and will work on arrays.\n                node.append.apply(node, object);\n            }\n            else {\n                assign(node, object);\n            }\n\n            return node;\n        },\n\n        default: (tag) => {\n            if (typeof tag !== 'string') {\n                // We used to support object as first argument. Deprecated.\n                // Todo: remove this message when we dont see any more errors\n                throw new Error('create(tag, content) accepts only a string as tag \"' + (typeof tag) + '\"')\n            }\n\n            return document.createElement(tag);\n        }\n    }),\n});\n\nexport default create;\n\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { create });\n}\n", "\n/** \ndelegate(map)\n\nTakes an object map of functions keyed to selectors, and returns a function that\nhandles event objects, delegating them to the first function whose selector \nmatches the event target. Functions are passed the target node and the event \nobject, plus any other arguments passed to the handler.\n\n```\ndelegate({\n\t'button': (button, event) => {}\n})\n```\n**/\n\nexport default function delegate(object) {\n\tif (typeof object !== 'object' || arguments.length > 1) {\n\t\tthrow new Error('delegate() now takes an object of selector:fn pairs.');\n\t}\n\n\t// Create an event handler that looks up the ancestor tree\n\t// to find selector.\n\tconst selectors = Object.keys(object);\n\n\treturn function handle(e) {\n\t\tconst target = e.target;\n\t\tlet n = -1;\n\n\t\twhile (selectors[++n]) {\n\t\t\tconst node = target.closest(selectors[n]);\n\t\t\tif (node) {\n\t\t\t\treturn object[selectors[n]](node, ...arguments);\n\t\t\t}\n\t\t}\n\t};\n}\n", "/**\nexec(regex, fn, string)\n\nCalls `fn` with the result of `regex.exec(string)` if that result is not null,\nand returns the resulting value.\n*/\n\nimport curry from './curry.js';\n\nexport function exec(regex, fn, string) {\n    let data;\n\n    // If string looks like a regex result, get rest of string\n    // from latest index\n    if (typeof string !== 'string' && string.input !== undefined && string.index !== undefined) {\n        data = string;\n        string = data.input.slice(\n            string.index\n            + string[0].length\n            + (string.consumed || 0)\n        );\n    }\n\n    // Look for tokens\n    const tokens = regex.exec(string);\n    if (!tokens) { return; }\n\n    const output = fn(tokens);\n\n    // If we have a parent tokens object update its consumed count\n    if (data) {\n        data.consumed = (data.consumed || 0)\n            + tokens.index\n            + tokens[0].length\n            + (tokens.consumed || 0) ;\n    }\n\n    return output;\n}\n\nexport default curry(exec, true);\n", "\nimport curry from './curry.js';\nimport { exec } from './exec.js';\n\nfunction error(regex, reducers, string) {\n    if (string.input !== undefined && string.index !== undefined) {\n        string = string.input;\n    }\n\n    throw new Error('Cannot parse string \"' + string + '\"');\n}\n\nfunction reduce(reducers, acc, tokens) {\n    let n = -1;\n\n    while (++n < tokens.length) {\n        acc = (tokens[n] !== undefined && reducers[n]) ? reducers[n](acc, tokens) : acc ;\n    }\n\n    // Call the optional done fn\n    return reducers.done ? reducers.done(acc, tokens) :\n        // Support the old .close() name\n        reducers.close ? reducers.close(acc, tokens) :\n        // Return the result\n        acc ;\n}\n\n/**\ncapture(regex, reducers, accumulator, string)\nParse `string` with `regex`, calling functions in `reducers` to modify\nand return `accumulator`.\n\nReducers is an object of functions keyed by the index of their capturing\ngroup in the regexp result (`0` corresponding to the entire regex match,\nthe first capturing group being at index `1`). Reducer functions are\ncalled in capture order for all capturing groups that captured something.\nReducers may also define the function 'done', which is called at the end\nof every capture. All reducer functions are passed the paremeters\n`(accumulator, tokens)`, where `tokens` is the regexp result, and are expected\nto return a value that is passed as an accumulator to the next reducer function.\n\nReducers may also define a function `'catch'`, which is called when a match\nhas not been made (where `'catch'` is not defined an error is thrown).\n\n```js\nconst parseValue = capture(/^\\s*(-?\\d*\\.?\\d+)(\\w+)?\\s*$/, {\n    // Create a new accumulator object each call\n    0: () => ({}),\n\n    1: (acc, tokens) => {\n        acc.number = parseFloat(tokens[1]);\n        return acc;\n    },\n\n    2: (acc, tokens) => {\n        acc.unit = tokens[2];\n        return acc;\n    }\n}, null);\n\nconst value = parseValue('36rem');    // { number: 36, unit: 'rem' }\n```\n*/\n\nexport function capture(regex, reducers, acc, string) {\n    const output = exec(regex, (tokens) => reduce(reducers, acc, tokens), string);\n\n    // If tokens is undefined exec has failed to apply regex to string\n    return output === undefined ?\n        // If there is a catch function, call it, otherwise error out\n        reducers.catch ?\n            reducers.catch(acc, string) :\n            error(regex, reducers, string) :\n\n        // Return the accumulator\n        output ;\n}\n\nexport default curry(capture, true);\n", "\nimport noop from '../../fn/modules/noop.js';\n\nexport default window.DEBUG ?\n    function log(name, ...args) {\n        if (window.console && window.console.log) {\n            window.console.log('%cdom %c' + name + '%c', 'color: #888888; font-weight: 400;', 'color: #3a8ab0; font-weight: 600;', 'color: inherit; font-weight: 400;', ...args);\n         }\n    } :\n    noop ;\n", "\n/**\nelement(name, options)\n\nRegisters a custom element and returns its constructor.\n\n- name: `'element-name'` or `'tag is=\"element-name\"'`\n- options: {\n    mode:       'open' or 'closed', defaults to 'closed'\n    focusable:  true or false, defaults to true\n    properties: An object of attribute and property handlers\n    \n    // Lifecycle handlers\n    stylesheet: optional string path to stylesheet for shadow DOM\n    construct:  called during element construction\n    connect:    called when element added to DOM\n    load:       called when stylesheet loaded\n    disconnect: called when element removed from DOM\n    enable:     called when form element enabled\n    disable:    called when form element disabled\n    reset:      called when form element reset\n    restore:    called when form element restored\n}\n\nThe name form `'tag is=\"element-name\"'` creates customised built-in elements in \nbrowsers that support the feature. Safari is a known culprit. Mileage will vary.\n\nThe effects of the `mode` option are subtle. In 'closed' mode, the element is\nnot given a publicly accessible `shadowRoot` property, and events that traverse\nthe shadow boundary are retargeted (as they are in 'open' mode) but also have\ntheir `path` list truncated.\n\nWhere the `properties` object contains a definition for a `value` property, work\nis done to give the element form field behaviour. The constructor is assigned\nthe property `formAssociated` which signals to the browser that it constructs\nform fields. Where they are not defined in `properties` the prototype is\nassigned default handlers for the standard properties `type`, `name`, `form`,\n`labels`, `validity`, `validationMessage`, `willValidate`, `checkValidity`\nand `reportValidity`. Form behaviour is also mildly polyfilled in browsers\nwithout support by inserting a hidden input inside the element but outside the\nshadow DOM. Mileage will vary. Managing focus can be problematic without browser \nsupport.\n\nAt the start of initialisation the `construct` handler is called. Use it to\nset up a shadow root and define event handlers. Children and attributes must\nnot be inspected or assigned at this point – doing so will throw in some cases,\neg. construction via `document.createElement()`.\n\nFollowing that, attribute handlers are called for attributes declared in the\nHTML. The parser normally calls these in source order, but this can be problematic\nif you require setup to run in a specific order so here they are run in the order\ndeclared in the `options.properties`.\n\nThen the `connect` handler is called when the element is placed in the DOM\nor if it is already in the DOM and is being upgraded.\n\nFinally the `load` handler is called after the first connect, and after any\nstylesheet links in the shadow DOM have loaded. If there are no links, it is\ncalled immediately after `connect`.\n\nAll lifecycle handlers are called with the parameter `(shadow)`.\n*/\n\nimport create  from './create.js';\nimport capture from '../../fn/modules/capture.js';\nimport log     from './log.js';\n\nconst $internals = Symbol('internals');\nconst $shadow    = Symbol('shadow');\n\nconst define = Object.defineProperties;\n\nconst constructors = {\n    // We need list only those whose constructor names do not match their tag\n    'a':        HTMLAnchorElement,\n    'dl':       HTMLDListElement,\n    'p':        HTMLParagraphElement,\n    'br':       HTMLBRElement,\n    'fieldset': HTMLFieldSetElement,\n    'hr':       HTMLHRElement,\n    'img':      HTMLImageElement,\n    'li':       HTMLLIElement,\n    'ol':       HTMLOListElement,\n    'optgroup': HTMLOptGroupElement,\n    'q':        HTMLQuoteElement,\n    'textarea': HTMLTextAreaElement,\n    'td':       HTMLTableCellElement,\n    'th':       HTMLTableCellElement,\n    'tr':       HTMLTableRowElement,\n    'tbody':    HTMLTableSectionElement,\n    'thead':    HTMLTableSectionElement,\n    'tfoot':    HTMLTableSectionElement,\n    'ul':       HTMLUListElement\n};\n\nconst formProperties = {\n    // These properties echo those provided by native form controls.\n    // They are not strictly required, but provided for consistency.\n    //type: { value: 'text' },\n\n    name: {\n        set: function(name) { return this.setAttribute('name', name); },\n        get: function() { return this.getAttribute('name') || ''; }\n    },\n\n    form:              { get: function() { return this[$internals].form; }},\n    labels:            { get: function() { return this[$internals].labels; }},\n    validity:          { get: function() { return this[$internals].validity; }},\n    validationMessage: { get: function() { return this[$internals].validationMessage; }},\n    willValidate:      { get: function() { return this[$internals].willValidate; }},\n    checkValidity:     { value: function() { return this[$internals].checkValidity(); }},\n    reportValidity:    { value: function() { return this[$internals].reportValidity(); }}\n};\n\nconst nothing   = {};\nconst onceEvent = { once: true };\nconst shadowParameterIndex = 0;\n\nlet supportsCustomisedBuiltIn = false;\n\nfunction getElementConstructor(tag) {\n        // Return a constructor from the known list of tag names – not all tags\n        // have constructor names that match their tags\n    return constructors[tag]\n        // Or assemble the tag name in the form \"HTMLTagElement\" and return\n        // that property of the window object\n        || window['HTML' + tag[0].toUpperCase() + tag.slice(1) + 'Element']\n        || (() => {\n            throw new Error('Constructor not found for tag \"' + tag + '\"');\n        })();\n}\n\n// Capture name and tag from <element-name> or <tag is=\"element-name\">, syntax\n// brackets and quotes optional\nconst captureNameTag = capture(/^\\s*<?([a-z][\\w]*-[\\w]+)>?\\s*$|^\\s*<?([a-z][\\w]*)\\s+is=[\"']?([a-z][\\w]*-[\\w]+)[\"']?>?\\s*$/, {\n    1: (data, captures) => ({\n        name: captures[1]\n    }),\n    \n    2: (data, captures) => ({\n        name: captures[3],\n        tag:  captures[2]\n    }),\n\n    catch: function(data, name) {\n        throw new SyntaxError('dom element() – name must be of the form \\'element-name\\' or \\'tag is=\"element-name\"\\' (' + name + ')')\n    }\n}, null);\n\nfunction transferProperty(elem, key) {\n    if (elem.hasOwnProperty(key)) {\n        const value = elem[key];\n        delete elem[key];\n        elem[key] = value;\n    }\n\n    return elem;\n}\n\nfunction createShadow(/*template, */elem, options) {\n    elem._initialLoad = true;\n\n    // Create a shadow root if there is DOM content. Shadows may be 'open' or\n    // 'closed'. Closed shadows are not exposed via element.shadowRoot, and\n    // events propagating from inside of them report the element as target.\n    const shadow = elem.attachShadow({\n        mode:           options.mode || 'closed',\n        delegatesFocus: options.focusable || false\n    });\n\n    if (options.stylesheet) {\n        const link = create('link', { rel: 'stylesheet', href: options.stylesheet });\n        shadow.append(link);\n    }\n\n    elem[$shadow] = shadow;\n\n    return shadow;\n}\n\nfunction attachInternals(elem) {\n    var internals;\n\n    // Use native attachInternals where it exists\n    if (elem.attachInternals) {\n        internals = elem.attachInternals();\n        if (internals.setFormValue) {\n            return internals;\n        }\n    }\n    else {\n        internals = {\n            shadowRoot: elem.shadowRoot\n        };\n    }\n\n    // Otherwise polyfill it with a pseudo internals object, actually a hidden\n    // input that we put inside element (but outside the shadow DOM). We may\n    // not yet put this in the DOM however – it violates the spec to give a\n    // custom element children before it's contents are parsed. Instead we\n    // wait until connectCallback.\n    internals.input = create('input', { type: 'hidden', name: elem.name });\n    elem.appendChild(internals.input);\n\n    // Polyfill internals object setFormValue\n    internals.setFormValue = function(value) {\n        this.input.value = value;\n    };\n\n    return internals;\n}\n\nfunction primeAttributes(elem) {\n    elem._initialAttributes = {};\n    elem._n = 0;\n}\n\nfunction advanceAttributes(elem, attributes, handlers) {\n    const values = elem._initialAttributes;\n\n    while(elem._n < attributes.length && values[attributes[elem._n]] !== undefined) {\n        //console.log('ADVANCE ATTR', attributes[elem._n]);\n        handlers[attributes[elem._n]].call(elem, values[attributes[elem._n]]);\n        ++elem._n;\n    }\n}\n\nfunction flushAttributes(elem, attributes, handlers) {\n    if (!elem._initialAttributes) { return; }\n\n    const values = elem._initialAttributes;\n\n    while(elem._n < attributes.length) {\n        if (values[attributes[elem._n]] !== undefined && handlers[attributes[elem._n]]) {\n            handlers[attributes[elem._n]].call(elem, values[attributes[elem._n]]);\n        }\n        ++elem._n;\n    }\n\n    delete elem._initialAttributes;\n    delete elem._n;\n}\n\nfunction hasPropertyAttribute(option) {\n    return !!option.attribute;\n}\n\nfunction hasPropertyDefinition(option) {\n    return option.set || option.get || option.hasOwnProperty('value');\n}\n\nfunction groupAttributeProperty(data, entry) {\n    if (hasPropertyAttribute(entry[1])) {\n        data.attributes[entry[0]] = entry[1].attribute;\n    }\n\n    if (hasPropertyDefinition(entry[1])) {\n        data.properties[entry[0]] = entry[1];\n    }\n\n    return data;\n}\n\nexport default function element(definition, lifecycle, api) {\n    const { name, tag } = captureNameTag(definition);\n\n    // Get the element constructor or the base HTMLElement constructor\n    const constructor = typeof tag === 'string' ?\n        getElementConstructor(tag) :\n        HTMLElement ;\n\n    const { attributes, properties } = api ?\n            Object.entries(api).reduce(groupAttributeProperty, {\n                attributes: {}, \n                properties: {}\n            }) :\n        // Support the old way, a single options object with props and lifecycle included\n        lifecycle.properties ?\n            Object.entries(lifecycle.properties).reduce(groupAttributeProperty, {\n                attributes: {}, \n                properties: {}\n            }) :\n        nothing ;\n\n    function Element() {\n        // Construct an instance from Constructor using the Element prototype\n        const elem   = Reflect.construct(constructor, arguments, Element);\n        const shadow = lifecycle.construct && lifecycle.construct.length > shadowParameterIndex ?\n            createShadow(elem, lifecycle) :\n            undefined ;\n\n        // Get access to the internal form control API\n        const internals = Element.formAssociated && attachInternals(elem) ;\n\n        if (tag) {\n            supportsCustomisedBuiltIn = true;\n        }\n\n        lifecycle.construct && lifecycle.construct.call(elem, shadow, internals);\n\n        // Preserve initialisation order of attribute initialisation by\n        // queueing them\n        if (attributes) {\n            primeAttributes(elem);\n\n            // Wait a tick to flush attributes\n            Promise.resolve(1).then(function() {\n                flushAttributes(elem, Element.observedAttributes, attributes);\n            });\n        }\n\n        // At this point, if properties have already been set before the\n        // element was upgraded, they exist on the elem itself, where we have\n        // just upgraded it's protytype to define those properties those\n        // definitions will never be reached. Either:\n        //\n        // 1. Define properties on the instance instead of the prototype\n        //    Object.defineProperties(elem, properties);\n        //\n        // 2. Take a great deal of care not to set properties before an element\n        //    is upgraded. I can't impose a restriction like that.\n        //\n        // 3. Copy defined properties to their prototype handlers and delete\n        //    them on the instance.\n        //\n        // Let's go with 3. I'm not happy you have to do this, though.\n        properties\n        && Object.keys(properties).reduce(transferProperty, elem);\n\n        return elem;\n    }\n\n\n    // Properties\n    //\n    // Must be defined before attributeChangedCallback, but I cannot figure out\n    // why. Where one of the properties is `value`, the element is set up as a\n    // form element.\n    Element.prototype = Object.create(constructor.prototype, properties) ;\n\n\n    // Form properties\n\n    if (properties && properties.value) {\n        // Flag the Element class as formAssociated\n        Element.formAssociated = true;\n        \n        // Define standard form properties\n        define(Element.prototype, formProperties);\n    \n        if (lifecycle.enable || lifecycle.disable) {\n            Element.prototype.formDisabledCallback = function(disabled) {\n                return disabled ?\n                    lifecycle.disable && lifecycle.disable.call(this, this[$shadow], this[$internals]) :\n                    lifecycle.enable && lifecycle.enable.call(this, this[$shadow], this[$internals]) ;\n            };\n        }\n        \n        if (lifecycle.reset) {\n            Element.prototype.formResetCallback = function() {\n                return lifecycle.reset.call(this, this[$shadow], this[$internals]);\n            };\n        }\n        \n        if (lifecycle.restore) {\n            Element.prototype.formStateRestoreCallback = function() {\n                return lifecycle.restore.call(this, this[$shadow], this[$internals]);\n            };\n        }\n    }\n\n\n    // Attributes\n\n    if (attributes) {\n        Element.observedAttributes = Object.keys(attributes);\n\n        Element.prototype.attributeChangedCallback = function(name, old, value) {\n            if (!this._initialAttributes) {\n                return attributes[name].call(this, value) ;\n            }\n\n            // Keep a record of attribute values to be applied in\n            // observedAttributes order\n            this._initialAttributes[name] = value;\n            advanceAttributes(this, Element.observedAttributes, attributes);\n        };\n    }\n\n\n    // Lifecycle\n\n    Element.prototype.connectedCallback = function() {\n        const elem      = this;\n        const shadow    = elem[$shadow];\n        const internals = elem[$internals];\n\n        // Initialise any attributes that appeared out of order\n        if (elem._initialAttributes) {\n            flushAttributes(elem, Element.observedAttributes, attributes);\n        }\n\n        // If we have simulated form internals, append the hidden input now\n        //if (elem[$internals] && !elem.attachInternals) {\n        //    elem.appendChild(elem[$internals].input);\n        //}\n\n        // If this is the first connect and there is an lifecycle.load fn,\n        // _initialLoad is true\n        if (elem._initialLoad) {\n            const links = shadow.querySelectorAll('link[rel=\"stylesheet\"]');\n\n            if (links.length) {\n                let count  = 0;\n                let n = links.length;\n\n                const load = function load(e) {\n                    if (++count >= links.length) {\n                        // Delete _initialLoad. If the element is removed\n                        // and added to the DOM again, stylesheets do not load\n                        // again\n                        delete elem._initialLoad;\n                        if (lifecycle.load) {\n                            log('element()', 'loaded', Array.from(links).map((link) => link.href).join('\\n'));\n                            lifecycle.load.call(elem, shadow);\n                        }\n                    }\n                };\n\n                const error = window.DEBUG ? function error(e) {\n                    console.error('Failed to load stylesheet', e.target.href);\n                    load(e);\n                } :\n                load ;\n\n                while (n--) {\n                    links[n].addEventListener('load', load, onceEvent);\n                    links[n].addEventListener('error', error, onceEvent);\n                }\n\n                lifecycle.connect && lifecycle.connect.call(this, shadow, internals);\n            }\n            else {\n                lifecycle.connect && lifecycle.connect.call(this, shadow, internals);\n                lifecycle.load    && lifecycle.load.call(this, shadow, internals);\n            }\n        }\n        else {\n            lifecycle.connect && lifecycle.connect.call(this, shadow, internals);\n        }\n    }\n\n    if (lifecycle.disconnect) {\n        Element.prototype.disconnectedCallback = function() {\n            return lifecycle.disconnect.call(this, this[$shadow], this[$internals]);\n        };\n    }\n\n    log('element()', '<' + (tag ? tag + ' is=' + name + '' : name) + '>');\n\n    window.customElements.define(name, Element, tag && { extends: tag });\n\n    // Where tag is supplied, element should have been registered as a customised \n    // built-in and the constructor would have run if any were in the DOM already.\n    // However, Safari does not support customised built-ins. Here we attempt to \n    // go some way towards filling in support by searching for elements and \n    // assigning their intended APIs to them.\n    if (tag && !supportsCustomisedBuiltIn) {\n        if (window.DEBUG) {\n            console.warn('Browser does not support customised built-in elements.\\nAttempting to partially polyfill instances of <' + tag + ' is=\"' + name + '\"> found in the DOM.');\n        }\n\n        document.querySelectorAll('[is=\"' + name + '\"]').forEach((element) => {\n            // Define properties on element\n            define(element, properties);\n\n            // Run constructor\n            lifecycle.construct && lifecycle.construct.apply(element);\n\n            // Detect and run attributes\n            let name;\n            for (name in attributes) {\n                const attribute = element.attributes[name];\n                if (attribute) {\n                    attributes[name].call(element, attribute.value);\n                }\n            }\n\n            lifecycle.connect && lifecycle.connect.apply(element);\n        });\n    }\n\n    return Element;\n}\n", "\nimport Stream from '../../fn/modules/stream.js';\n//import features from './features.js';\n\nconst assign  = Object.assign;\nconst rspaces = /\\s+/;\n\n/*\nfunction prefixType(type) {\n\treturn features.events[type] || type ;\n}\n*/\n\n/**\nevents(type, node)\n\nReturns a mappable stream of events heard on `node`:\n\n```js\nvar stream = events('click', document.body);\n.map(get('target'))\n.each(function(node) {\n    // Do something with nodes\n});\n```\n\nStopping the stream removes the event listeners:\n\n```js\nstream.stop();\n```\n\nThe first parameter may also be an options object, which must have a `type`\nproperty. The `select: '...'` property allows for delegation of an event from\nthe selected target. Other properties, eg. `passive: true` are passed to\naddEventListener options.\n\n```js\nvar stream = events({ type: 'scroll', passive: true, select: '' }, document.body);\n```\n*/\n\n\n// DOM click events may be simulated on inputs when their labels are\n// clicked. The tell-tale is they have the same timeStamp. Track click\n// timeStamps.\nvar clickTimeStamp = 0;\n\nwindow.addEventListener('click', (e) => clickTimeStamp = e.timeStamp);\n\nfunction listen(listener, type) {\n    listener.node.addEventListener(type, listener, listener.options);\n    return listener;\n}\n\nfunction unlisten(listener, type) {\n    listener.node.removeEventListener(type, listener);\n    return listener;\n}\n\nfunction Listener(controller, type, options, node) {\n\tthis.controller = controller;\n    this.types   = type.split(rspaces);//.map(prefixType);\n\tthis.options = options;\n    this.node    = node;\n    this.select  = options && options.select;\n\n\t// Potential hard-to-find error here if type has repeats, ie 'click click'.\n\t// Lets assume nobody is dumb enough to do this, I dont want to have to\n\t// check for that every time.\n\tthis.types.reduce(listen, this);\n}\n\nassign(Listener.prototype, {\n\tstop: function() {\n\t\tthis.types.reduce(unlisten, this);\n\t},\n\n    handleEvent: function(e) {\n        // Ignore clicks with the same timeStamp as previous clicks –\n        // they are likely simulated by the browser.\n        if (e.type === 'click' && e.timeStamp <= clickTimeStamp) {\n            return;\n        }\n\n        // If there is a selector and the target doesn't match, shoofty\n        // outta here\n        if (this.select) {\n            const selectedTarget = e.target.closest(this.select);\n            if (!selectedTarget) { return; }\n            e.selectedTarget = selectedTarget;\n        }\n\n        this.controller.push(e);\n    }\n});\n\nexport default function events(type, node) {\n\tlet options;\n\n\tif (typeof type === 'object') {\n\t\toptions = type;\n\t\ttype    = options.type;\n\t}\n\n\treturn new Stream((controller) =>\n        controller.done(new Listener(controller, type, options, node))\n    );\n}\n\n\n/**\nisPrimaryButton(e)\nReturns `true` if event is from the primary (normally the left or only)\nbutton of an input device. Use this to filter out right-clicks.\n*/\n\nexport function isPrimaryButton(e) {\n\t// Ignore mousedowns on any button other than the left (or primary)\n\t// mouse button, or when a modifier key is pressed.\n\treturn (e.which === 1 && !e.ctrlKey && !e.altKey && !e.shiftKey);\n}\n\n/**\npreventDefault(e)\nCalls `e.preventDefault()`.\n**/\n\nexport function preventDefault(e) {\n\te.preventDefault();\n}\n\n/**\nisTargetEvent(e)\nTests whether `e.target === e.currentTarget`.\n**/\nexport function isTargetEvent(e) {\n\treturn e.target === e.currentTarget;\n}\n\nexport function isNotPrevented(e) {\n\treturn !e.defaultPrevented;\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n\twindow.dom ? (window.dom.events = events) : (window.dom = { events });\n}\n\n", "\n/**\nget(name, object)\nGet property `name` of `object`.\n*/\n\nimport curry from './curry.js';\n\nexport function get(key, object) {\n    // Todo? Support WeakMaps and Maps and other map-like objects with a\n    // get method - but not by detecting the get method\n    return object[key];\n}\n\nexport default curry(get, true);\n", "/**\ntoType(object)\nReturns `typeof object`.\n*/\n\nexport default function toType(object) {\n    return typeof object;\n}\n", "import curry from './curry.js';\n\n/**\nparseValue(units, string)\n\nParse `string` as a value with a unit (such as `\"3px\"`). Parameter `units` is an\nobject of functions keyed by the unit postfix. It may also have a `catch`\nfunction.\n\n```js=\nconst value = parseValue({\n    px: function(n) {\n        return n;\n    },\n\n    catch: function(string) {\n        if (typeof string === 'number') {\n            return string;\n        }\n\n        throw new Error('Cannot parse px value');\n    }\n}, '36px');\n```\n**/\n\n// Be generous in what we accept, space-wise, but exclude spaces between the \n// number and the unit\nconst runit = /^\\s*([+-]?\\d*\\.?\\d+)([^\\s\\d]*)\\s*$/;\n\nexport function parseValue(units, string) {\n    // Allow number to pass through\n    if (typeof string === 'number') {\n        return string;        \n    }\n\n    var entry = runit.exec(string);\n\n    if (!entry || !units[entry[2] || '']) {\n        if (!units.catch) {\n            throw new Error('Cannot parse value \"' + string + '\" with provided units ' + Object.keys(units).join(', '));\n        }\n\n        return entry ?\n            units.catch(parseFloat(entry[1]), entry[2]) :\n            units.catch(parseFloat(string)) ;\n    }\n\n    return units[entry[2] || ''](parseFloat(entry[1]));\n}\n\nexport default curry(parseValue);\n", "/**\nstyle(property, node)\n\nReturns the computed style `property` of `node`.\n\n    style('transform', node);            // returns transform\n\nIf `property` is of the form `\"property:name\"`, a named aspect of the property\nis returned.\n\n    style('transform:rotate', node);     // returns rotation, as a number, in radians\n    style('transform:scale', node);      // returns scale, as a number\n    style('transform:translateX', node); // returns translation, as a number, in px\n    style('transform:translateY', node); // returns translation, as a number, in px\n*/\n\nvar rpx          = /px$/;\nvar styleParsers = {\n\t\"transform:translateX\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\treturn parseFloat(values[4]);\n\t},\n\n\t\"transform:translateY\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\treturn parseFloat(values[5]);\n\t},\n\n\t\"transform:scale\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\tvar a = parseFloat(values[0]);\n\t\tvar b = parseFloat(values[1]);\n\t\treturn Math.sqrt(a * a + b * b);\n\t},\n\n\t\"transform:rotate\": function(node) {\n\t\tvar matrix = computedStyle('transform', node);\n\t\tif (!matrix || matrix === \"none\") { return 0; }\n\t\tvar values = valuesFromCssFn(matrix);\n\t\tvar a = parseFloat(values[0]);\n\t\tvar b = parseFloat(values[1]);\n\t\treturn Math.atan2(b, a);\n\t}\n};\n\nfunction valuesFromCssFn(string) {\n\treturn string.split('(')[1].split(')')[0].split(/\\s*,\\s*/);\n}\n\nfunction computedStyle(name, node) {\n\treturn window.getComputedStyle ?\n\t\twindow\n\t\t.getComputedStyle(node, null)\n\t\t.getPropertyValue(name) :\n\t\t0 ;\n}\n\nexport default function style(name, node) {\n    // If name corresponds to a custom property name in styleParsers...\n    if (styleParsers[name]) { return styleParsers[name](node); }\n\n    var value = computedStyle(name, node);\n\n    // Pixel values are converted to number type\n    return typeof value === 'string' && rpx.test(value) ?\n        parseFloat(value) :\n        value ;\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { style });\n}\n", "// Units\n\nimport id         from '../../fn/modules/id.js';\nimport overload   from '../../fn/modules/overload.js';\nimport toType     from '../../fn/modules/to-type.js';\nimport parseValue from '../../fn/modules/parse-value.js';\nimport style      from './style.js';\n\n\n/* Track document font size */\n\nlet emSize;\nlet remSize;\n\nfunction getEmSize() {\n    if (!emSize) {\n        if (window.DEBUG) {\n            console.warn('Calculating root em value may cause reflow as user font-size cannot be known without setting <html style=\"font-size: 100%;\">');\n        }\n\n        const styledFontSize = document.documentElement.style.fontSize;\n        document.documentElement.style.fontSize = '100%';\n        emSize = style(\"font-size\", document.documentElement);\n        document.documentElement.style.fontSize = styledFontSize || '';\n    }\n\n    return emSize;\n}\n\nfunction getRemSize() {\n    if (!remSize) {\n        remSize = style(\"font-size\", document.documentElement);\n    }\n\n    return remSize;\n}\n\nwindow.addEventListener('resize', () => {\n    emSize  = undefined;\n    remSize = undefined;\n});\n\n/**\npx(value)\nTakes a number in pixels or a string of the form `'10px'`, `'10em'`, `'10rem'`,\n`'100vw'`, `'100vh'`, `'100vmin'` or `'100vmax'`, and returns a numeric value\nin pixels.\n*/\n\nexport const px = overload(toType, {\n    'number': id,\n\n    'string': parseValue({\n        em: function(n) {\n            return getEmSize() * n;\n        },\n\n        px: function(n) {\n            return n;\n        },\n\n        rem: function(n) {\n            return getRemSize() * n;\n        },\n\n        vw: function(n) {\n            return window.innerWidth * n / 100;\n        },\n\n        vh: function(n) {\n            return window.innerHeight * n / 100;\n        },\n\n        vmin: function(n) {\n            return window.innerWidth < window.innerHeight ?\n                window.innerWidth * n / 100 :\n                window.innerHeight * n / 100 ;\n        },\n\n        vmax: function(n) {\n            return window.innerWidth < window.innerHeight ?\n                window.innerHeight * n / 100 :\n                window.innerWidth * n / 100 ;\n        }\n    })\n});\n\nexport default px;\n\n/**\nem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `em`, eg. `0.625`. Depends on the user defined browser\n`font-size`.\n*/\n\nexport function em(n) {\n    return px(n) / getEmSize();\n}\n\n/**\nrem(value)\nTakes numeric value in px, or CSS length of the form `'10px'`, and returns\na numeric value in `rem`, eg. `0.625`. Depends on the `font-size` of the\ndocumentElement.\n*/\n\nexport function rem(n) {\n    return px(n) / getRemSize();\n}\n\n/**\nvw(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vw`, eg. `120`. Depends on the width of the viewport at\nrender time.\n*/\n\nexport function vw(n) {\n    return 100 * px(n) / window.innerWidth;\n}\n\n/**\nvh(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vh`, eg. `120`. Depends on the height of the viewport at\nrender time.\n*/\n\nexport function vh(n) {\n    return 100 * px(n) / window.innerHeight;\n}\n\n/**\nvmin(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmin`, eg. `120`. Depends on the minimum dimension of the\nviewport at render time.\n*/\n\nexport function vmin(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerWidth :\n            window.innerHeight\n    );\n}\n\n/**\nvmax(value)\nTakes number in pixels or CSS length of the form `'10em'` and returns a\nnumeric value in `vmax`, eg. `120`. Depends on the maximum dimension of the\nviewport at render time.\n*/\n\nexport function vmax(n) {\n    return 100 * px(n) / (\n        window.innerWidth < window.innerHeight ?\n            window.innerHeight :\n            window.innerWidth\n    );\n}\n\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { px, em, rem, vw, vh, vmin, vmax });\n}\n", "\n/**\ngestures(options, node)\n\nReturns a stream of streams of events. Each stream of events represents the\nmotion of a single finger. The types of events the stream contains is a\n`'pointerdown'` followed by any number of `'pointermove'`s and a `'pointerup'`\nor `'pointercancel'` event.\n\n```js\ngestures({ selector: '.thing', threshold: '0.5rem', device: 'mouse pen touch' }, document)\n.each(function(events) {\n    const e0 = events.shift();\n\n    events.each(function(e1) {\n        const distance = Math.pow(\n            Math.pow(e1.clientX - e0.clientX, 2),\n            Math.pow(e1.clientY - e0.clientY, 2),\n        0.5);\n\n        console.log(distance);\n    });\n});\n```\n\nThe `options` object may optionally contain any of:\n\n```js\n{\n    // Listen to gestures on a given device type. Internally the pointer events'\n    // e.pointerType is matched against this string: it may contain any of the\n    // types 'pen', 'mouse' and 'touch'. Where not defined, all pointer types\n    // trigger a gesture\n    device: 'mouse pen',\n\n    // Listen to gestures inside a selected element or elements\n    selector: '.class'\n\n    // Determine a minimum distance a finger must travel before a gesture is\n    // considered to have started\n    threshold: '0.25rem'\n}\n```\n*/\n\nimport get      from '../../fn/modules/get.js';\nimport overload from '../../fn/modules/overload.js';\nimport Stream   from '../../fn/modules/stream.js';\nimport px       from './parse-length.js';\n\nconst assign = Object.assign;\n\nexport const config = {\n    // Number of pixels, or string CSS length, that a pressed pointer travels\n    // before gesture is started.\n    threshold: 4,\n\n    ignoreTags: {\n        textarea: true,\n        input: true,\n        select: true\n    }\n};\n\n\n/* Pointermove, pointerup and pointercancel handler */\n\nfunction checkThreshold(threshold, e0, e1) {\n    var distX = e1.clientX - e0.clientX;\n    var distY = e1.clientY - e0.clientY;\n\n    // Return false if the threshold has not been crossed.\n    return !(\n        (distX * distX) + (distY * distY) < (threshold * threshold)\n    );\n}\n\nfunction Pointermove(stream, events, options) {\n    this.stream    = stream;\n    this.events    = events;\n    this.options   = options;\n    this.pointerId = events[0].pointerId;\n    this.threshold = px(options.threshold);\n\n    document.addEventListener('pointermove', this);\n    document.addEventListener('pointerup', this);\n    document.addEventListener('pointercancel', this);\n\n    // If threshold is 0 start gesture immediately\n    if (this.threshold === 0) {\n        this.createGesture();\n    }\n}\n\nassign(Pointermove.prototype, {\n    handleEvent: overload(get('type'), {\n        'pointermove': function(e) {\n            if (this.pointerId !== e.pointerId) {\n                console.log('Not the same pointer');\n                return;\n            }\n\n            this.events.push(e);\n\n            // Before we cross the threshold we need to check it on each move\n            if (!this.isGesture && checkThreshold(this.threshold, this.events[0], e)) {\n                this.createGesture();\n            }\n\n            // After we want to cancel any default actions\n            else {\n                e.preventDefault();\n            }\n        },\n\n        'default': function(e) {\n            if (this.pointerId !== e.pointerId) {\n                console.log('Not the same pointer');\n                return;\n            }\n\n            this.events.push(e);\n            this.stop();\n        }\n    }),\n\n    createGesture: function() {\n        this.isGesture = true;\n\n        this.stream.push(new Stream((stream) => {\n            // Push in existing events\n            stream.push.apply(stream, this.events);\n\n            // Have the stream controller take over as the events buffer\n            this.events = stream;\n        }));\n    },\n\n    stop: function() {\n        // Stop the gesture stream\n        this.events.stop && this.events.stop();\n\n        // Remove the listeners\n        document.removeEventListener('pointermove', this);\n        document.removeEventListener('pointerup', this);\n        document.removeEventListener('pointercancel', this);\n    }\n});\n\n\n/* Pointerdown handler */\n\nfunction isIgnoreTag(e) {\n    var tag = e.target.tagName;\n    return tag && (!!config.ignoreTags[tag.toLowerCase()] || e.target.draggable);\n}\n\nfunction Pointerdown(stream, node, options) {\n    this.stream  = stream;\n    this.node    = node;\n    this.options = options;\n    this.node.addEventListener('pointerdown', this);\n}\n\nassign(Pointerdown.prototype, {\n    handleEvent: function(e) {\n        // Ignore non-primary buttons\n        if (e.button !== 0) { return; }\n\n        // Check pointer type is in options\n        if (this.options.device && !this.options.device.includes(e.pointerType)) { return; }\n\n        // Ignore form and interactive elements\n        if (isIgnoreTag(e)) { return; }\n\n        // Check target matches selector\n        if (this.options.selector && !e.target.closest(this.options.selector)) { return; }\n\n        // Copy event to keep the true target around, as target is mutated on\n        // the event if it passes through a shadow boundary after being handled\n        // here, resulting in a rare but gnarly bug hunt.\n        var event = {\n            type:          e.type,\n            target:        e.target,\n            currentTarget: e.currentTarget,\n            clientX:       e.clientX,\n            clientY:       e.clientY,\n            timeStamp:     e.timeStamp,\n            pointerId:     e.pointerId\n        };\n\n        new Pointermove(this.stream, [event], this.options);\n    },\n\n    // Stop the gestures stream\n    stop: function() {\n        this.node.removeEventListener('pointerdown', this);\n\n        // Dont do this, we are responding to source (thi.stream) here already\n        //this.stream.stop();\n    }\n});\n\n\n/* Gestures */\n\nexport default function gestures(options, node) {\n    options = node ?\n        options ? assign({}, config, options) : config :\n        config ;\n\n    node = node ?\n        node :\n        options ;\n\n    return new Stream((source) => source.done(new Pointerdown(source, node, options)));\n}\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { gestures });\n}\n", "\n// Much of this code has been purloined from targetable.js – do we need the\n// hashchange tracking here? I have commented it\n\nimport Stream     from '../../fn/modules/stream.js';\nimport { Source } from '../../fn/modules/stream/stream.js';\n\nconst assign = Object.assign;\n\nconst captureOptions = {\n    capture: true,\n    passive: true\n};\n\n/*\nConfig\n*/\n\nexport const config = {\n    minScrollEventInterval: 0.0375,\n    maxScrollEventInterval: 0.18\n};\n\n// Capture scroll events in capture phase, as scroll events from elements\n// other than document do not bubble.\n\nvar trackingInterval = config.maxScrollEventInterval;\n\nfunction adjustTrackingInterval(times) {\n    // Dynamically adjust maxScrollEventInterval to tighten it up,\n    // imposing a baseline of 60ms (0.0375s * 1.6)\n\n    let n = times.length;\n    let interval = 0;\n\n    while (--n) {\n        const t = times[n] - times[n - 1];\n        interval = t > interval ? t : interval;\n    }\n\n    interval = interval < config.minScrollEventInterval ?\n        config.minScrollEventInterval :\n        interval ;\n\n    trackingInterval =  (1.4 * interval) > config.maxScrollEventInterval ?\n        config.maxScrollEventInterval :\n        (1.4 * interval) ;\n}\n\nfunction update(source, e) {\n    const { times } = source;\n\n    source.value.stop();\n    source.value = undefined;\n\n    if (times.length > 1) {\n        adjustTrackingInterval(times);\n    }\n\n    times.length = 0;\n}\n\nfunction Scrolls(element) {\n    this.element = element;\n    this.times   = [];\n}\n\nassign(Scrolls.prototype, Source.prototype, {\n    start: function() {\n        // Method may be used once only\n        //if (window.DEBUG) { this.start = startError; }\n\n        /*\n        window.addEventListener('hashchange', function hashchange(e) {\n            hashtime = e.timeStamp / 1000;\n            //console.log('hashchange', hashtime, window.location.hash);\n        });\n        */\n\n        this.element.addEventListener('scroll', this, captureOptions);\n\n        // Update count of running streams\n        ++Stream.count;\n    },\n\n    handleEvent: function(e) {\n        // Ignore the first scroll event following a hashchange. The browser sends a\n        // scroll event even where a target cannot be scrolled to, such as a\n        // navigation with position: fixed, for example. This can cause targetable\n        // to recalculate again, and shift the target back to one fo the targetables,\n        // where it should stay on the navigation element.\n        const time = e.timeStamp / 1000;\n\n        // Make sure this only happens once after a hashchange\n        /*if (hashtime !== undefined) {\n            // If we are not mid-scroll, and the latest hashchange was less than\n            // 0.1s ago, ignore\n            if (!times.length && hashtime > time - 0.1) {\n                //console.log('scroll', 'ignored');\n                hashtime = undefined;\n                return;\n            }\n\n            hashtime = undefined;\n        }*/\n\n        this.times.push(time);\n\n        if (this.value) {\n            clearTimeout(this.timer);\n            this.value.push(e);\n        }\n        else {\n            this.value = Stream.of(e);\n            this.target.push(this.value);\n        }\n\n        // Update only when there is a trackingInterval second pause in scrolling\n        this.timer = setTimeout(update, trackingInterval * 1000, this, e);\n    },\n\n    stop: function() {\n        this.element.removeEventListener('scroll', scroll);\n        Source.prototype.stop.apply(this, arguments);\n    }\n});\n\nexport default function scrolls(element) {\n    return new Stream(new Scrolls(element));\n}\n", "\nconst assign      = Object.assign;\nconst CustomEvent = window.CustomEvent;\n\nconst defaults    = {\n\t// The event bubbles (false by default)\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\tbubbles: true,\n\n\t// The event may be cancelled (false by default)\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Event/Event\n\tcancelable: true\n\n\t// Trigger listeners outside of a shadow root (false by default)\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Event/composed\n\t//composed: false\n};\n\n/**\nEvent(type, properties)\n\nCreates a CustomEvent of type `type`.\nAdditionally, `properties` are assigned to the event object.\n*/\n\nexport default function Event(type, options) {\n\tlet settings;\n\n\tif (typeof type === 'object') {\n\t\tsettings = assign({}, defaults, type);\n\t\ttype = settings.type;\n        delete settings.type;\n\t}\n\n\tif (options && options.detail) {\n\t\tif (settings) {\n\t\t\tsettings.detail = options.detail;\n\t\t}\n\t\telse {\n\t\t\tsettings = assign({ detail: options.detail }, defaults);\n\t\t}\n\t}\n\n    // Settings accepted by CustomEvent:\n    // detail:     any\n    // bubbles:    true | false\n    // cancelable: true | false\n    // composed:   true | false\n    // https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent\n\tvar event = new CustomEvent(type, settings || defaults);\n\n\tif (options) {\n\t\tdelete options.detail;\n\t\tassign(event, options);\n\t}\n\n\treturn event;\n}\n", "\n/**\ntrigger(type, node)\n\nTriggers event of `type` on `node`. Returns `false` if the event default was\nprevented, otherwise `true`.\n\n```\ntrigger('dom-activate', node);\n```\n*/\n\n/**\ntrigger(data, node)\n\nTriggers an event described by `data` on `node`. The `data` object must have a\n`type` property. Use the `details` property to carry a data payload.\n\n```\ntrigger({\n    type: 'dom-activate',\n    details: {...}\n}, node);\n```\n\nReturns `false` if the event default was prevented, otherwise `true`.\n*/\n\nimport curry from '../../fn/modules/curry.js';\nimport Event from './event.js';\n\nexport function trigger(type, node) {\n    let properties;\n\n    if (typeof type === 'object') {\n        properties = type;\n        type = properties.type;\n        delete properties.type;\n    }\n\n    // Don't cache events. It prevents you from triggering an event of a\n\t// given type from inside the handler of another event of that type.\n\tconst event = Event(type, properties);\n    return node.dispatchEvent(event);\n}\n\nexport default curry(trigger, true);\n\n// Expose to console in DEBUG mode\nif (window.DEBUG) {\n    Object.assign(window.dom || (window.dom = {}), { trigger });\n}\n", "\n/*\nDetect and scroll to active slides. The active is the slide currently in\nscroll-snap alignment.\n*/\n\nimport { px }      from '../../dom/modules/parse-length.js';\nimport rect        from '../../dom/modules/rect.js';\nimport { trigger } from '../../dom/modules/trigger.js';\n\n\nfunction getPaddedBox(scroller) {\n    const box          = rect(scroller);\n    const computed     = window.getComputedStyle(scroller, null);\n    const paddingLeft  = px(computed.getPropertyValue('padding-left'));\n    const paddingRight = px(computed.getPropertyValue('padding-right'));\n\n    box.leftPadding   = box.left + paddingLeft;\n    box.rightPadding  = box.left + box.width - paddingRight;\n    box.centrePadding = box.leftPadding + (box.width - paddingLeft - paddingRight) / 2;\n\n    return box;\n}\n\nfunction getSnapX(element) {\n    // Todo: do we need webkit property here?\n    const snap = window\n        .getComputedStyle(element, null)\n        .getPropertyValue('scroll-snap-align');\n\n    // Imagine a detection line half a slides' width to the right of\n    // the left, the centre, or the right...\n    return snap.endsWith('start') ? 'left' :\n        snap.endsWith('end')   ? 'right' :\n        'centre' ;\n}\n\nfunction scrollToTarget(scroller, target, behavior) {\n    const scrollerBox = getPaddedBox(scroller);\n    const targetBox   = rect(target);\n    const snap        = getSnapX(target);\n\n    // Move scroll position to target slide, taking into account\n    // scroll-snap-align of the slide\n    scroller.scrollTo({\n        top:  scroller.scrollTop,\n        left: scroller.scrollLeft + (\n            snap === 'left' ? targetBox.left - scrollerBox.leftPadding :\n            snap === 'right' ? targetBox.right - scrollerBox.rightPadding :\n            targetBox.left + (targetBox.width / 2) - scrollerBox.centrePadding\n        ),\n        behavior: behavior\n    });\n}\n\nexport function scrollTo(scroller, target, behavior) {\n    scrollToTarget(scroller, target, 'smooth');\n}\n\nexport function jumpTo(scroller, target) {\n    scroller.style.setProperty('scroll-behavior', 'auto', 'important');\n    scrollToTarget(scroller, target, 'auto');\n    scroller.style.setProperty('scroll-behavior', '');\n}\n\nfunction getActive(scroller, children) {\n    const { leftPadding, rightPadding, centrePadding } = getPaddedBox(scroller);\n\n    let n = children.length;\n    let slide;\n\n    while ((slide = children[--n])) {\n        const slideRect = rect(slide);\n        if (!slideRect) { continue; }\n\n        // Todo: do we need webkit property here?\n        const snap = getSnapX(slide);\n\n        // Imagine a detection line half a slides' width to the right of\n        // the left, the centre, or the right...\n        const detection = (slideRect.width / 2) + (\n            snap === 'left' ? leftPadding :\n            snap === 'right' ? rightPadding :\n            centrePadding\n        );\n\n        // ...and a slide registration position at it's corresponding left,\n        // centre or right position. Safari reports 2 values for\n        // scroll-snap-align it's the second that is the inline axis value\n        const x = snap === 'left' ? slideRect.left :\n            snap === 'right' ? slideRect.right :\n            slideRect.left + slideRect.width / 2 ;\n\n        // If position has crossed the detection going left, we're in the money\n        if (x <= detection) {\n            break;\n        }\n    }\n\n    // Return active slide\n    return slide;\n}\n\nfunction isGhost(slide) {\n    return !!slide.dataset.slideIndex;\n}\n\nexport function updateActive(data) {\n    const { scroller, children, elements } = data;\n    const current = getActive(scroller, elements);\n    let active;\n\n    // If current is a loop ghost jump to the actual slide it references\n    if (isGhost(current)) {\n        active = children[current.dataset.slideIndex];\n        jumpTo(scroller, active);\n    }\n    else {\n        active = current;\n    }\n\n    if (active === data.active) { return; }\n    data.active = active;\n    if (active === undefined) { return; }\n    data.actives.push(active);\n    trigger('slide-active', active);\n}\n", "\nimport events   from '../../dom/modules/events.js';\nimport overload from '../../fn/modules/overload.js';\n\nimport { updateActive } from './active.js';\n\nexport const processPointers = overload((data, e) => e.type, {\n    pointerdown: function(data, e) {\n        // First event is touchstart or mousedown\n        data.e0 = e;\n        data.x0 = e.clientX;\n        data.y0 = e.clientY;\n\n        return data;\n    },\n\n    pointermove: function(data, e) {\n        const x1 = e.clientX;\n        const y1 = e.clientY;\n\n        // Determine whether to start a gesture\n        if (!data.gesturing) {\n            // If the movement is more vertical than horizontal, don't count it\n            // as a swipe. Stop the stream and get out of here.\n            if (Math.abs(x1 - data.x0) < Math.abs(y1 - data.y0)) {\n                data.pointers.stop();\n                data.pointers = undefined;\n                data.e0 = undefined;\n                data.x0 = undefined;\n                data.y0 = undefined;\n                return;\n            }\n\n            data.scrollLeft0 = data.scroller.scrollLeft;\n            //data.scroller.classList.add('gesturing');\n            data.scroller.style.setProperty('scroll-snap-type', 'none', 'important');\n            data.scroller.style.setProperty('scroll-behavior', 'auto', 'important');\n            data.gesturing = true;\n        }\n\n        const dx = e.clientX - data.x0;\n        data.scroller.scrollLeft = data.scrollLeft0 - dx;\n\n        return data;\n    },\n\n    // Catches pointerup and pointercancel\n    default: function(data, e) {\n        const scroller = data.scroller;\n\n        // Track the end of click to allow click suppression\n        data.clickSuppressTime = e.timeStamp;\n\n        // Here we must go through a whole rigmarole in an attempt to avoid\n        // scroll jumps at the end of a swipe. Find out where it is, ...\n        const scrollLeft1 = scroller.scrollLeft;\n        scroller.style.setProperty('scroll-snap-type', '');\n\n        // and where it would snap to.\n        const scrollLeft2 = scroller.scrollLeft;\n\n        // If those numbers are the same we are probably in FF, where removing\n        // scroll-snap type doesn't seem to change much.\n        if (scrollLeft1 === scrollLeft2) {\n            // But FF has sensible smooth scroll behaviour, reset it.\n            scroller.style.setProperty('scroll-behavior', '');\n        }\n        else {\n            // We may as well preemptively update the active slide now, since we\n            // are sitting in the new position. This is not a crucial step, just\n            // makes the UI react a bit more quickly.\n            updateActive(data);\n\n            // Otherwise we have to do things the hard way. Switch scroll-snap\n            // off again and put scroll back to position 1, ...\n            scroller.style.setProperty('scroll-snap-type', 'none', 'important');\n            scroller.scrollLeft = scrollLeft1;\n\n            // then manually smooth scroll over to position 2, ...\n            scroller.style.setProperty('scroll-behavior', '');\n            scroller.scrollTo({\n                top:  scroller.scrollTop,\n                left: scrollLeft2,\n                behavior: 'smooth'\n            });\n\n            // and finally, switch scroll snapping back on when that scroll is\n            // over. Wait for two frames without a scroll event to pass before\n            // resetting scroll-snap.\n            let frame;\n            const scrolls = events({ type: 'scroll', passive: true }, scroller).each(() => {\n                cancelAnimationFrame(frame);\n                frame = requestAnimationFrame(() =>\n                    frame = requestAnimationFrame(() => {\n                        scroller.style.setProperty('scroll-snap-type', '');\n                        scrolls.stop();\n                    })\n                );\n            });\n\n            // Ooof. What a polava.\n        }\n\n        data.gesturing = false;\n        data.e0 = undefined;\n        data.x0 = undefined;\n        data.y0 = undefined;\n        data.pointers  = undefined;\n        data.scrollLeft0 = undefined;\n\n        return data;\n    }\n});\n", "\n/*\nAutoplay\n*/\n\nimport id         from '../../fn/modules/id.js';\nimport get        from '../../fn/modules/get.js';\nimport overload   from '../../fn/modules/overload.js';\nimport parseValue from '../../fn/modules/parse-value.js';\nimport Stream     from '../../fn/modules/stream.js';\nimport events     from '../../dom/modules/events.js';\n\n\nconst parseTime = parseValue({\n    's':  id,\n    'ms': (n) => n / 1000\n});\n\n/*\nTODO: dont autoplay when hidden??\n\nevents('visibilitychange', document).each((e) => {\n    if (document.hidden) {\n\n    }\n    else {\n\n    }\n});\n*/\n\nfunction change(data) {\n    const { active, children, elements, host } = data;\n    const i = elements.indexOf(active);\n    const target = elements[i + 1] || children[0];\n    //console.log('AUTOPLAY CHANGE', target);\n    data.autoplay.timer = null;\n    if (!target) { return; }\n    host.active = target;\n}\n\nfunction update(data) {\n    const { active, style } = data;\n    const duration = parseTime(\n        window\n        .getComputedStyle(active)\n        .getPropertyValue('--slide-duration') ||\n        style.getPropertyValue('--slide-duration')\n    );\n\n    clearTimeout(data.autoplay.timer);\n    //console.log('AUTOPLAY UPDATE', duration);\n    data.autoplay.timer = setTimeout(change, duration * 1000, data);\n}\n\nfunction cancel(data) {\n    //console.log('AUTOPLAY CANCEL');\n    clearTimeout(data.autoplay.timer);\n    data.autoplay.timer = null;\n}\n\nexport function enableAutoplay(data) {\n    const { actives, host } = data;\n\n    // Add an object to store autoplay state\n    const autoplay = data.autoplay = {};\n\n    // Create a stream of hover states starting with false. Note that this is\n    // an assumption - the cursor may well be in hover state when autoplay is\n    // enabled. TODO: detect current hover state (move this stream to a 'permanent'\n    // stram in element.js? Make distributor push initial value?)\n    const hovers = Stream.merge(\n        [false],\n        events('pointerenter pointerleave', host)\n        .map((e) => e.type === 'pointerenter')\n    );\n\n    // Create a stream of focus inside state\n    const focuses = Stream.merge(\n        [host.contains(document.activeElement)],\n        events('focusin focusout', host)\n        .map(overload(get('type'), {\n            'focusin': (e) => true,\n            'focusout': (e) => host.contains(e.relatedTarget)\n        }))\n    )\n    // Deduplicate\n    .map(((v) => (value) => (v === value ? undefined : (v = value)))());\n\n    // Schedule a change timer on every activate where the user is not\n    // hovering, or at the end of the hover\n    autoplay.updates = Stream\n        .combine({ active: actives, hover: hovers, focus: focuses })\n        .each((state) => (state.hover || state.focus ?\n            cancel(data) :\n            update(data)\n        ));\n}\n\nexport function disableAutoplay(data) {\n    cancel(data);\n    data.autoplay.updates.stop();\n    data.autoplay = undefined;\n}\n", "\nimport nothing from '../../fn/modules/nothing.js';\nimport Stream  from '../../fn/modules/stream.js';\nimport rect    from '../../dom/modules/rect.js';\n\nimport { jumpTo } from './active.js';\n\nconst loopOverflow = 2400;\n\n\nfunction toLoopGhost(slide, i) {\n    const ghost = slide.cloneNode(true);\n    ghost.dataset.slideIndex = i;\n    ghost.removeAttribute('id');\n    ghost.setAttribute('aria-hidden', 'true');\n    ghost.tabIndex = '-1';\n    return ghost;\n}\n\nexport function isSlide(slide) {\n    // Filter out loop ghosts\n    return !slide.dataset.slideIndex;\n}\n\nfunction render(data) {\n    const { active, children, host, scroller } = data;\n\n    if (children.length < 2) {\n        return;\n    }\n\n    // Expand children to the left and right by loopOverflow px\n    const boxes = children.map(rect);\n    const left  = boxes[0].left;\n    const right = boxes[boxes.length - 1].right;\n\n    let n = 0;\n    while (boxes[++n] && boxes[n].left < left + loopOverflow);\n    const appends = children.slice(0, n).map(toLoopGhost);\n\n    n = boxes.length - 1;\n    while (boxes[--n] && boxes[n].right > right - loopOverflow);\n    const prepends = children.slice(++n).map((slide, i) => toLoopGhost(slide, n + i));\n\n    // Will cause slotchange event\nconsole.log('LOOP RENDER', prepends.length, appends.length, active);\n\n    host.prepend.apply(host, prepends);\n    host.append.apply(host, appends);\n\n    data.loop.prepends = prepends;\n    data.loop.appends  = appends;\n\n    jumpTo(scroller, active || children[0]);\n}\n\nexport function enableLoop(data) {\n    const { mutations } = data;\n\n    // Add an object to store loop state\n    const loop = data.loop = {};\n\n    if (!data.loaded) {\n        return;\n    }\n\n    // Render buttons when children change\n    loop.mutations = mutations\n        .map((o) => o)\n        .each(() => render(data));\n}\n\nexport function disableLoop(data) {\n    if (data.loop) {\n        data.loop.prepends && data.loop.prepends.forEach((slide) => slide.remove());\n        data.loop.appends  && data.loop.appends.forEach((slide) => slide.remove());\n        data.loop.mutations.stop();\n        data.loop = undefined;\n    }\n}\n", "\nimport create from '../../dom/modules/create.js';\n\nexport function enableControls(data) {\n    if (!data.controls) {\n        const nav = create('nav', { part: 'controls' });\n        data.shadow.append(nav);\n        data.controls = nav;\n    }\n}\n\nexport function disableControls(data) {\n    console.log('CONTROLS DISABLE');\n}\n", "\nimport Stream   from '../../fn/modules/stream.js';\nimport create   from '../../dom/modules/create.js';\nimport delegate from '../../dom/modules/delegate.js';\n\nimport { enableControls } from './controls.js';\n\nfunction updateButtons(prev, next, elements, i) {\n    // Preemptively hide buttons now (before new active is detected at\n    // end of scroll)\n    if (i === 0) {\n        prev.hidden = true;\n    }\n    else {\n        prev.hidden = false;\n    }\n\n    if (i === elements.length - 1) {\n        next.hidden = true;\n    }\n    else {\n        next.hidden = false;\n    }\n}\n\nfunction update(data) {\n    const { active, elements, navigation: { prev, next } } = data;\n    const i = elements.indexOf(active);\n    updateButtons(prev, next, elements, i)\n}\n\nexport function enableNavigation(data, state) {\n    const { host, actives, clicks, mutations } = data;\n\n    // Set up nav::part(controls) element\n    enableControls(data);\n\n    // Add an object to store navigation state\n    const navigation = data.navigation = {\n        prev: create('button', { part: 'prev-button', type: \"button\", name: \"navigation\", value: \"-1\", html: 'Previous' }),\n        next: create('button', { part: 'next-button', type: \"button\", name: \"navigation\", value: \"1\", html: 'Next' })\n    };\n\n    data.controls.prepend(navigation.prev, navigation.next);\n\n    // Add object for storing navigation state\n    navigation.mutations = mutations.each(() => update(data));\n\n    // Create a new stream of actives starting with the current active\n    navigation.actives = actives.each(() => update(data));\n\n    navigation.clicks = clicks.each(delegate({\n        '[name=\"navigation\"]': function(button, e) {\n            const value  = parseFloat(button.value);\n            const i      = data.elements.indexOf(data.active) + value;\n            const target = data.elements[i];\n\n            if (!target) { return; }\n\n            host.active = target;\n            updateButtons(navigation.prev, navigation.next, data.elements, i);\n        }\n    }));\n}\n\nexport function disableNavigation(data) {\n    data.navigation.prev.remove();\n    data.navigation.next.remove();\n    data.navigation.mutations.stop();\n    data.navigation.actives.stop();\n    data.navigation.clicks.stop();\n    data.navigation = undefined;\n}\n", "\nimport nothing  from '../../fn/modules/nothing.js';\nimport Stream   from '../../fn/modules/stream.js';\nimport create   from '../../dom/modules/create.js';\nimport delegate from '../../dom/modules/delegate.js';\n\nimport { enableControls } from './controls.js';\n\n\nfunction update(pagination, children, target) {\n    const { active, buttons, index } = pagination;\n\n    // Do nothing where target is already the active page-button\n    if (active === target) { return; }\n\n    if (index > -1) {\n        pagination.activeSpan.remove();\n        buttons.children[index].part.remove('page-button-active');\n    }\n\n    const i = children.indexOf(target);\n    if (i === -1) { return; }\n\n    buttons.children[i].part.add('page-button-active');\n    buttons.children[i].append(pagination.activeSpan);\n    pagination.index  = i;\n    pagination.active = target;\n}\n\nfunction render(controls, pagination, shadow, children) {\n    if (pagination.buttons) {\n        pagination.buttons.remove();\n        pagination.buttons = undefined;\n    }\n\n    // Don't generate pagination when there are 0 or 1 slides\n    if (children.length < 2) { return; }\n\n    pagination.buttons = create('div', {\n        part: 'pagination',\n        children: children.map((slide, i) => create('button', {\n            part: 'page-button',\n            type: 'button',\n            name: 'pagination',\n            value: i\n        }))\n    });\n\n    controls.append(pagination.buttons);\n}\n\nexport function enablePagination(data, state) {\n    const { shadow, actives, clicks, mutations } = data;\n\n    // Set up nav::part(controls) element\n    enableControls(data);\n\n    // Add an object to store autoplay state\n    const pagination = data.pagination = {\n        // Element containing accessibility text marking a button as active\n        activeSpan: create('span', { class: 'invisible', text: '(Current slide)' })\n    };\n\n    // Render buttons when children change\n    pagination.mutations = mutations.each(() =>\n        render(data.controls, pagination, shadow, data.children.filter((slide) => !slide.dataset.slideIndex))\n    );\n\n    // Create a new stream of actives starting with the current active\n    // TODO: Make distributor push initial value?\n    pagination.actives = actives.each(() =>\n        update(pagination, data.children.filter((slide) => !slide.dataset.slideIndex), data.active)\n    );\n\n    pagination.clicks = clicks.each(delegate({\n        '[name=\"pagination\"]': function(button, e) {\n            const { host } = data;\n            const children = data.children.filter((slide) => !slide.dataset.slideIndex);\n            const target = children[button.value];\n\n            if (!target) { return; }\n            host.active = target;\n\n            // Preemptively highlight pagination button\n            update(pagination, children, target);\n        }\n    }));\n}\n\nexport function disablePagination(data) {\n    data.pagination.buttons.remove();\n    data.pagination.mutations.stop();\n    data.pagination.actives.stop();\n    data.pagination.clicks.stop();\n    data.pagination = undefined;\n}\n", "\n// Not true in iPhone iOS.\nexport const fullscreenEnabled = document.fullscreenEnabled\n    || document.mozFullscreenEnabled\n    || document.webkitFullscreenEnabled\n    || document.msFullscreenEnabled ;\n\nexport function getFullscreenElement() {\n    return document.fullscreenElement\n        || document.webkitFullscreenElement\n        || document.mozFullScreenElement\n        || document.msFullscreenElement ;\n}\n\nexport function enterFullscreen(node) {\n    return node.requestFullscreen ? node.requestFullscreen() :\n        node.webkitRequestFullscreen ? node.webkitRequestFullscreen() :\n        node.mozRequestFullScreen ? node.mozRequestFullScreen() :\n        node.msRequestFullscreen ? node.msRequestFullscreen() :\n        undefined ;\n}\n\nexport function exitFullscreen() {\n    document.exitFullscreen ? document.exitFullscreen() :\n    document.webkitExitFullscreen ? document.webkitExitFullscreen() :\n    document.mozCancelFullScreen ? document.mozCancelFullScreen() :\n    document.msExitFullscreen ? document.msExitFullscreen() :\n    undefined ;\n}\n", "\nimport create   from '../../dom/modules/create.js';\nimport delegate from '../../dom/modules/delegate.js';\nimport { fullscreenEnabled, getFullscreenElement, enterFullscreen, exitFullscreen } from '../../dom/modules/fullscreen.js';\n\nimport { enableControls } from './controls.js';\n\nexport function enableFullscreen(data, state) {\n    const { host } = data;\n\n    if (!fullscreenEnabled) {\n        if (window.DEBUG) {\n            console.warn('Fullscreen mode not available in this browser');\n        }\n\n        return;\n    }\n\n    // Set up nav::part(controls) element\n    enableControls(data);\n\n    // Add an object to store navigation state\n    const fullscreen = data.fullscreen = {\n        button: create('button', {\n            part: 'fullscreen-button',\n            type: \"button\",\n            name: \"fullscreen\",\n            html: 'Open in fullscreen'\n        }),\n    };\n\n    data.controls.append(fullscreen.button);\n\n    fullscreen.clicks = data.clicks.each(delegate({\n        '[name=\"fullscreen\"]': (button, e) => {\n            const fullscreenCurrent = getFullscreenElement();\n\n            // Make button act as toggle: close the fullscreen\n            if (fullscreenCurrent === host) {\n                exitFullscreen();\n                fullscreen.button.part.remove('fullscreen-button-active');\n                fullscreen.button.innerHTML = 'Open in fullscreen';\n                return;\n            }\n\n            if (fullscreenCurrent) {\n                exitFullscreen();\n            }\n\n            enterFullscreen(host);\n            fullscreen.button.part.add('fullscreen-button-active');\n            fullscreen.button.innerHTML = 'Close fullscreen';\n        }\n    }));\n}\n\nexport function disableFullscreen(data) {\n    const { host } = data;\n    const fullscreenCurrent = getFullscreenElement();\n\n    if (fullscreenCurrent === host) {\n        exitFullscreen();\n    }\n\n    data.fullscreen.button.remove();\n    data.fullscreen.clicks.stop();\n    data.fullscreen = undefined;\n}\n", "\n// Polyfill Element.scrollTo() for Safari\nimport '../dom/polyfills/element.scrollto.js';\n\n/** <slide-show>\n\nImport `<slide-show>` custom element. This registers the custom\nelement and upgrades instances already in the DOM.\n\n```html\n<script type=\"module\" src=\"./build/element.js\"></script>\n\n<slide-show loop controls=\"navigation\">\n   <img src=\"./images/donkeys.jpg\" draggable=\"false\" />\n   <img src=\"./images/tractor.jpg\" draggable=\"false\" />\n   <img src=\"./images/mauverin.jpg\" draggable=\"false\" />\n</slide-show>\n```\n\nChildren of a `<slide-show>` are displayed as slides in a horizontal grid.\n**/\n\nimport equals      from '../fn/modules/equals.js';\nimport noop        from '../fn/modules/noop.js';\nimport nothing     from '../fn/modules/nothing.js';\nimport Distributor from '../fn/modules/stream/distributor.js';\nimport Stream      from '../fn/modules/stream.js';\nimport create      from '../dom/modules/create.js';\nimport delegate    from '../dom/modules/delegate.js';\nimport element     from '../dom/modules/element.js';\nimport events, { isPrimaryButton } from '../dom/modules/events.js';\nimport gestures    from '../dom/modules/gestures.js';\nimport { px }      from '../dom/modules/parse-length.js';\nimport rect        from '../dom/modules/rect.js';\nimport Scrolls     from '../dom/modules/scrolls.js';\n\nimport { scrollTo, jumpTo, updateActive } from './modules/active.js';\nimport { processPointers } from './modules/swipe.js';\nimport { enableAutoplay, disableAutoplay } from './modules/autoplay.js';\nimport { enableLoop, disableLoop, isSlide } from './modules/loop.js';\nimport { enableNavigation, disableNavigation } from './modules/navigation.js';\nimport { enablePagination, disablePagination } from './modules/pagination.js';\nimport { enableFullscreen, disableFullscreen } from './modules/fullscreen.js';\n\nconst $data = Symbol('data');\n\n\nfunction getWidth(scroller, slides, children) {\n    let n = children.length;\n    let r = -Infinity;\n\n    while (n--) {\n        const box   = rect(children[n]);\n        const right = box.x + box.width;\n        r = right > r ? right : r;\n    }\n\n    const box   = rect(slides);\n    const style = getComputedStyle(scroller);\n    const pl    = px(style.paddingLeft);\n    const pr    = px(style.paddingRight);\n\n    return pl + pr + r - box.x;\n}\n\nfunction updateWidth(scroller, slides, children) {\n    const width = getWidth(scroller, slides, children);\n    scroller.style.setProperty('--scroll-width', width + 'px');\n}\n\n\n/* Element */\n\nconst lifecycle = {\n    // Get path to dir of this module\n    stylesheet:\n        // Support the old path system baked into the Nendaz project\n        window.customElementStylesheetPath && window.customElementStylesheetPath + 'slide-show.shadow.css' ||\n        window.elementSlideShowStylesheet ||\n        import.meta.url.replace(/\\/[^\\/]*([?#].*)?$/, '/') + 'shadow.css',\n\n    construct: function(shadow) {\n        // Shadow DOM\n        const slides   = create('slot', { part: 'slides' });\n        const scroller = create('div',  { class: 'scroller', children: [slides] });\n\n        // A place to put optional UI (fullscreen close buttons etc)\n        //const optional = create('slot', { name: 'ui', part: 'ui' });\n\n        // Add slots to shadow\n        shadow.append(scroller);\n\n        const slotchanges  = events('slotchange', slides).distribute();\n        const mutations    = Stream.of().distribute({ memory: true });\n        const clicks       = events('click', shadow).filter(isPrimaryButton).distribute();\n        const focuses      = events('focusin', this);\n        const resizes      = events('resize', window);\n        const fullscreens  = events('fullscreenchange', window);\n        const scrolls      = Scrolls(scroller);\n        const swipes       = gestures({ threshold: '0.25rem', device: 'mouse' }, shadow).filter(() => data.children.length > 1);\n        const actives      = Stream.of().distribute({ memory: true });\n\n        // Private data\n        const data = this[$data] = {\n            clickSuppressTime: -Infinity,\n            host:     this,\n            style:    window.getComputedStyle(this),\n            elements: nothing,\n            children: nothing,\n            shadow,\n            scroller,\n            slides,\n            actives,\n            slotchanges,\n            mutations,\n            clicks\n        };\n\n        slotchanges.each(() => {\n            const elements = slides.assignedElements();\n            data.elements = elements;\n            updateWidth(data.scroller, data.slides, data.elements);\n\n            const children = data.elements.filter(isSlide);\n            if (!equals(data.children, children)) {\n                data.children = children;\n                mutations.push(children);\n            }\n        });\n\n        resizes.each(() =>\n            updateWidth(data.scroller, data.slides, data.elements)\n        );\n\n        // Prevent default on immediate clicks after a gesture, and don't let\n        // them out: this is a gesture not a click\n        clicks.each(function(e) {\n            const time = window.performance.now();\n            if (time - data.clickSuppressTime < 120) {\n                e.preventDefault();\n                e.stopPropagation();\n            }\n        });\n\n        // Enable single finger scroll on mouse devices. Bad idea in my opinion,\n        // but designers tend to want it.\n        swipes.each((pointers) => {\n            // Keep a reference to pointers, it's used inside processPointers\n            data.pointers = pointers;\n            pointers.reduce(processPointers, data);\n        });\n\n        fullscreens.each((e) => {\n            // If this slide-show was involved in the fullscreen change\n            // reposition the active slide, it may have been shuftied.\n            if (e.target === this || e.target.contains(this)) {\n                jumpTo(scroller, data.active);\n            }\n        });\n\n        scrolls.each((stream) =>\n            stream\n            .each(noop)\n            .done(() => updateActive(data))\n        );\n\n        // Chrome behaves nicely when shifting focus between slides, Safari and\n        // FF not so much. Let's give them a helping hand at displaying the\n        // focused slide. Todo: FF not getting this.\n        focuses.map((e) =>\n            // Is e.target a slide\n            data.children.indexOf(e.target) !== -1 ? e.target :\n            // Or inside a slide\n            data.children.find((child) => child.contains(e.target))\n        )\n        .each((target) => scrollTo(data.scroller, target));\n    },\n\n    load: function (shadow) {\n        const data = this[$data];\n        data.loaded = true;\n\n        if (this.loop) {\n            enableLoop(data);\n        }\n        else {\n            disableLoop(data);\n        }\n\n        // Update width hack now we have some style loaded\n        updateWidth(data.scroller, data.slides, data.elements);\n\n        // Update and bind to slotchanges on load so that initial `slide-active`\n        // event is guaranteed to be sent after initialisation. (In Chrome and\n        // FF initial `slotchange` event is always sent before load, but not so\n        // in Safari where either order may happen.)\n        updateActive(data);\n        data.slotchanges.each(() => updateActive(data));\n    }\n};\n\nconst properties = {\n    active: {\n        /**\n        .active\n        Returns the currently scroll-snapped child element.\n\n        ```js\n        const activeSlide = slideshow.active;\n        ```\n\n        May be set to one of the child elements, or to the id of one of the\n        child elements. Setting this property causes the slide to change.\n\n        ```js\n        slideshow.active = 'slide-1';\n        ```\n        **/\n\n        set: function(target) {\n            const data = this[$data];\n\n            // Accept an id\n            const child = typeof target !== 'object' ?\n                this.querySelector('#' + (/^\\d/.test((id + '')[0]) ?\n                    '\\\\3' + (id + '')[0] + ' ' + (id + '').slice(1) :\n                    target)\n                ) : target ;\n\n            if (!child) {\n                throw new Error('Cannot set active – not a child of slide-show');\n            }\n\n            scrollTo(data.scroller, child);\n        },\n\n        get: function() {\n            return this[$data].active;\n        }\n    },\n\n    autoplay: {\n        /**\n        autoplay=\"\"\n        Boolean attribute. When present the slide-show activates the next\n        slide after a pause. The pause duration may be set in CSS via the\n        `--slide-duration` variable.\n        **/\n        attribute: function(value) {\n            // Delegate to property\n            this.autoplay = (value !== null);\n        },\n\n        /**\n        .autoplay\n        Boolean property. When `true` the slide-show activates the next\n        slide after a pause. The pause duration may be set in CSS via the\n        `--slide-duration` variable.\n        **/\n        set: function(state) {\n            const data = this[$data];\n            return !state === !data.autoplay ?\n                undefined :\n                state ?\n                    enableAutoplay(data) :\n                    disableAutoplay(data) ;\n        },\n\n        get: function() {\n            const data = this[$data];\n            return !!data.autoplay;\n        }\n    },\n\n    controls: {\n        /**\n        controls=\"\"\n\n        Treated as a boolean or a token list. If it is present but empty\n        all tokens are considered to be true. Otherwise, possible tokens are:\n\n        <strong>navigation</strong> enables previous and next buttons. The\n        buttons may be styled with `::part(previous)` and `::part(next)`\n        selectors. To change their text content, import and modify\n        `config.trans`:\n\n        ```js\n        import { config } from './bolt/elements/slide-show/module.js';\n        config.trans['Previous'] = 'Précédent';\n        config.trans['Next']     = 'Suivant';\n        ```\n\n        <strong>pagination</strong> enables a row of pagination dots. The\n        dots may be styled with `::part(page)`.\n        **/\n        attribute: function(value) {\n            const data = this[$data];\n            let navigationState, paginationState, fullscreenState;\n\n            // If value is a string of tokens\n            if (typeof value === 'string' && value !== '') {\n                const state = value.split(/\\s+/);\n                navigationState = state.includes('navigation');\n                paginationState = state.includes('pagination');\n                fullscreenState = state.includes('fullscreen');\n            }\n            else {\n                const state = value !== null;\n                navigationState = state;\n                paginationState = state;\n                fullscreenState = state;\n            }\n\n            if (!!navigationState !== !!data.navigation) {\n                if (navigationState) {\n                    enableNavigation(data);\n                }\n                else {\n                    disableNavigation(data);\n                }\n            }\n\n            if (!!paginationState !== !!data.pagination) {\n                if (paginationState) {\n                    enablePagination(data);\n                }\n                else {\n                    disablePagination(data);\n                }\n            }\n\n            if (!!fullscreenState !== !!data.fullscreen) {\n                if (fullscreenState) {\n                    enableFullscreen(data);\n                }\n                else {\n                    disableFullscreen(data);\n                }\n            }\n        }\n    },\n\n    loop: {\n        /**\n        loop=\"\"\n        Boolean attribute. Makes the slideshow behave as a continuous loop.\n        **/\n        attribute: function(value) {\n            // Delegate to property\n            this.loop = (value !== null);\n        },\n\n        /**\n        .loop\n        Boolean property. Makes the slideshow behave as a continuous loop.\n        **/\n        set: function(state) {\n            const data = this[$data];\n            return !state === !data.loop ?\n                undefined :\n                state ?\n                    enableLoop(data) :\n                    disableLoop(data) ;\n        },\n\n        get: function() {\n            const data = this[$data];\n            return !!data.loop;\n        }\n    },\n\n    previous: {\n        value: function prev() {\n            console.log('Todo: advance slide');\n        }\n    },\n\n    next: {\n        value: function next() {\n            console.log('Todo: back slide');\n        }\n    }\n};\n\nexport default element('slide-show', lifecycle, properties);\n"],
  "mappings": "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",
  "names": []
}
